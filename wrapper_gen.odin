
// GENERATED FILE; DO NOT EDIT
// this file was generated by generator_v2/generate.py

package imgui


import "core:fmt"
import "core:strings"

create_context :: CreateContext

destroy_context :: DestroyContext

get_current_context :: GetCurrentContext

set_current_context :: SetCurrentContext

get_io :: GetIO

get_style :: GetStyle

new_frame :: NewFrame

end_frame :: EndFrame

render :: Render

get_draw_data :: GetDrawData

show_demo_window :: ShowDemoWindow

show_metrics_window :: ShowMetricsWindow

show_debug_log_window :: ShowDebugLogWindow

show_stack_tool_window :: ShowStackToolWindow

show_about_window :: ShowAboutWindow

show_style_editor :: ShowStyleEditor

show_style_selector :: proc(label: string) -> bool {
	return ShowStyleSelector(semisafe_string_to_cstring(label))
}

show_font_selector :: proc(label: string) {
	ShowFontSelector(semisafe_string_to_cstring(label))
}

show_user_guide :: ShowUserGuide

get_version :: GetVersion

style_colors_dark :: StyleColorsDark

style_colors_light :: StyleColorsLight

style_colors_classic :: StyleColorsClassic

begin :: proc(name: string, p_open: ^bool = nil, flags: Window_Flags = {  }) -> bool {
	return Begin(semisafe_string_to_cstring(name), p_open, flags)
}

end :: End

begin_child :: proc {
	begin_child_str,
	begin_child_id,
}
begin_child_str :: proc(str_id: string, size: [2]f32 = {0, 0}, border: bool = false, flags: Window_Flags = {  }) -> bool {
	return BeginChild_Str(semisafe_string_to_cstring(str_id), size, border, flags)
}
begin_child_id :: BeginChild_ID

end_child :: EndChild

is_window_appearing :: IsWindowAppearing

is_window_collapsed :: IsWindowCollapsed

is_window_focused :: IsWindowFocused

is_window_hovered :: IsWindowHovered

get_window_draw_list :: GetWindowDrawList

get_window_dpi_scale :: GetWindowDpiScale

get_window_pos :: proc() -> (p_out: [2]f32) {
	GetWindowPos(&p_out)
	return
}

get_window_size :: proc() -> (p_out: [2]f32) {
	GetWindowSize(&p_out)
	return
}

get_window_width :: GetWindowWidth

get_window_height :: GetWindowHeight

get_window_viewport :: GetWindowViewport

set_next_window_pos :: SetNextWindowPos

set_next_window_size :: SetNextWindowSize

set_next_window_size_constraints :: SetNextWindowSizeConstraints

set_next_window_content_size :: SetNextWindowContentSize

set_next_window_collapsed :: SetNextWindowCollapsed

set_next_window_focus :: SetNextWindowFocus

set_next_window_scroll :: SetNextWindowScroll

set_next_window_bg_alpha :: SetNextWindowBgAlpha

set_next_window_viewport :: SetNextWindowViewport

set_window_pos :: proc {
	set_window_pos_vec2,
	set_window_pos_str,
	set_window_pos_window_ptr,
}
set_window_pos_vec2 :: SetWindowPos_Vec2
set_window_pos_str :: proc(name: string, pos: [2]f32, cond: Cond = {  }) {
	SetWindowPos_Str(semisafe_string_to_cstring(name), pos, cond)
}
set_window_pos_window_ptr :: SetWindowPos_WindowPtr

set_window_size :: proc {
	set_window_size_vec2,
	set_window_size_str,
	set_window_size_window_ptr,
}
set_window_size_vec2 :: SetWindowSize_Vec2
set_window_size_str :: proc(name: string, size: [2]f32, cond: Cond = {  }) {
	SetWindowSize_Str(semisafe_string_to_cstring(name), size, cond)
}
set_window_size_window_ptr :: SetWindowSize_WindowPtr

set_window_collapsed :: proc {
	set_window_collapsed_bool,
	set_window_collapsed_str,
	set_window_collapsed_window_ptr,
}
set_window_collapsed_bool :: SetWindowCollapsed_Bool
set_window_collapsed_str :: proc(name: string, collapsed: bool, cond: Cond = {  }) {
	SetWindowCollapsed_Str(semisafe_string_to_cstring(name), collapsed, cond)
}
set_window_collapsed_window_ptr :: SetWindowCollapsed_WindowPtr

set_window_focus :: proc {
	set_window_focus_nil,
	set_window_focus_str,
}
set_window_focus_nil :: SetWindowFocus_Nil
set_window_focus_str :: proc(name: string) {
	SetWindowFocus_Str(semisafe_string_to_cstring(name))
}

set_window_font_scale :: SetWindowFontScale

get_content_region_avail :: proc() -> (p_out: [2]f32) {
	GetContentRegionAvail(&p_out)
	return
}

get_content_region_max :: proc() -> (p_out: [2]f32) {
	GetContentRegionMax(&p_out)
	return
}

get_window_content_region_min :: proc() -> (p_out: [2]f32) {
	GetWindowContentRegionMin(&p_out)
	return
}

get_window_content_region_max :: proc() -> (p_out: [2]f32) {
	GetWindowContentRegionMax(&p_out)
	return
}

get_scroll_x :: GetScrollX

get_scroll_y :: GetScrollY

set_scroll_x :: proc {
	set_scroll_x_float,
	set_scroll_x_window_ptr,
}
set_scroll_x_float :: SetScrollX_Float
set_scroll_x_window_ptr :: SetScrollX_WindowPtr

set_scroll_y :: proc {
	set_scroll_y_float,
	set_scroll_y_window_ptr,
}
set_scroll_y_float :: SetScrollY_Float
set_scroll_y_window_ptr :: SetScrollY_WindowPtr

get_scroll_max_x :: GetScrollMaxX

get_scroll_max_y :: GetScrollMaxY

set_scroll_here_x :: SetScrollHereX

set_scroll_here_y :: SetScrollHereY

set_scroll_from_pos_x :: proc {
	set_scroll_from_pos_x_float,
	set_scroll_from_pos_x_window_ptr,
}
set_scroll_from_pos_x_float :: SetScrollFromPosX_Float
set_scroll_from_pos_x_window_ptr :: SetScrollFromPosX_WindowPtr

set_scroll_from_pos_y :: proc {
	set_scroll_from_pos_y_float,
	set_scroll_from_pos_y_window_ptr,
}
set_scroll_from_pos_y_float :: SetScrollFromPosY_Float
set_scroll_from_pos_y_window_ptr :: SetScrollFromPosY_WindowPtr

push_font :: PushFont

pop_font :: PopFont

push_style_color :: proc {
	push_style_color_u32,
	push_style_color_vec4,
}
push_style_color_u32 :: PushStyleColor_U32
push_style_color_vec4 :: PushStyleColor_Vec4

pop_style_color :: PopStyleColor

push_style_var :: proc {
	push_style_var_float,
	push_style_var_vec2,
}
push_style_var_float :: PushStyleVar_Float
push_style_var_vec2 :: PushStyleVar_Vec2

pop_style_var :: PopStyleVar

push_tab_stop :: PushTabStop

pop_tab_stop :: PopTabStop

push_button_repeat :: PushButtonRepeat

pop_button_repeat :: PopButtonRepeat

push_item_width :: PushItemWidth

pop_item_width :: PopItemWidth

set_next_item_width :: SetNextItemWidth

calc_item_width :: CalcItemWidth

push_text_wrap_pos :: PushTextWrapPos

pop_text_wrap_pos :: PopTextWrapPos

get_font :: GetFont

get_font_size :: GetFontSize

get_font_tex_uv_white_pixel :: proc() -> (p_out: [2]f32) {
	GetFontTexUvWhitePixel(&p_out)
	return
}

get_color_u32 :: proc {
	get_color_u32_col,
	get_color_u32_vec4,
	get_color_u32_u32,
}
get_color_u32_col :: GetColorU32_Col
get_color_u32_vec4 :: GetColorU32_Vec4
get_color_u32_u32 :: GetColorU32_U32

get_style_color_vec4 :: GetStyleColorVec4

separator :: Separator

same_line :: SameLine

new_line :: NewLine

spacing :: Spacing

dummy :: Dummy

indent :: Indent

unindent :: Unindent

begin_group :: BeginGroup

end_group :: EndGroup

get_cursor_pos :: proc() -> (p_out: [2]f32) {
	GetCursorPos(&p_out)
	return
}

get_cursor_pos_x :: GetCursorPosX

get_cursor_pos_y :: GetCursorPosY

set_cursor_pos :: SetCursorPos

set_cursor_pos_x :: SetCursorPosX

set_cursor_pos_y :: SetCursorPosY

get_cursor_start_pos :: proc() -> (p_out: [2]f32) {
	GetCursorStartPos(&p_out)
	return
}

get_cursor_screen_pos :: proc() -> (p_out: [2]f32) {
	GetCursorScreenPos(&p_out)
	return
}

set_cursor_screen_pos :: SetCursorScreenPos

align_text_to_frame_padding :: AlignTextToFramePadding

get_text_line_height :: GetTextLineHeight

get_text_line_height_with_spacing :: GetTextLineHeightWithSpacing

get_frame_height :: GetFrameHeight

get_frame_height_with_spacing :: GetFrameHeightWithSpacing

push_id :: proc {
	push_id_str_str,
	push_id_ptr,
	push_id_int,
}
push_id_str_str :: proc(str_id: string) {
	PushID_StrStr(raw_data(str_id), cast([^]u8) (uintptr(raw_data(str_id)) + uintptr(len(str_id))))
}
push_id_ptr :: PushID_Ptr
push_id_int :: PushID_Int

pop_id :: PopID

get_id :: proc {
	get_id_str_str,
	get_id_ptr,
}
get_id_str_str :: proc(str_id: string) -> ID {
	return GetID_StrStr(raw_data(str_id), cast([^]u8) (uintptr(raw_data(str_id)) + uintptr(len(str_id))))
}
get_id_ptr :: GetID_Ptr

text_unformatted :: proc(text: string) {
	TextUnformatted(raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))))
}

text_colored :: proc(col: [4]f32, fmt_: string, _args_: ..any) {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	TextColored(col, "%s", cstring(raw_data(_fmt_sb.buf)))
}

text_disabled :: proc(fmt_: string, _args_: ..any) {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	TextDisabled("%s", cstring(raw_data(_fmt_sb.buf)))
}

text_wrapped :: proc(fmt_: string, _args_: ..any) {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	TextWrapped("%s", cstring(raw_data(_fmt_sb.buf)))
}

label_text :: proc(label: string, fmt_: string, _args_: ..any) {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	LabelText(semisafe_string_to_cstring(label), "%s", cstring(raw_data(_fmt_sb.buf)))
}

bullet_text :: proc(fmt_: string, _args_: ..any) {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	BulletText("%s", cstring(raw_data(_fmt_sb.buf)))
}

separator_text :: proc(label: string) {
	SeparatorText(semisafe_string_to_cstring(label))
}

button :: proc(label: string, size: [2]f32 = {0, 0}) -> bool {
	return Button(semisafe_string_to_cstring(label), size)
}

small_button :: proc(label: string) -> bool {
	return SmallButton(semisafe_string_to_cstring(label))
}

invisible_button :: proc(str_id: string, size: [2]f32, flags: Button_Flags = {  }) -> bool {
	return InvisibleButton(semisafe_string_to_cstring(str_id), size, flags)
}

arrow_button :: proc(str_id: string, dir: Dir) -> bool {
	return ArrowButton(semisafe_string_to_cstring(str_id), dir)
}

checkbox :: proc(label: string, v: ^bool) -> bool {
	return Checkbox(semisafe_string_to_cstring(label), v)
}

checkbox_flags :: proc {
	checkbox_flags_int_ptr,
	checkbox_flags_uint_ptr,
	checkbox_flags_s64_ptr,
	checkbox_flags_u64_ptr,
}
checkbox_flags_int_ptr :: proc(label: string, flags: ^i32, flags_value: i32) -> bool {
	return CheckboxFlags_IntPtr(semisafe_string_to_cstring(label), flags, flags_value)
}
checkbox_flags_uint_ptr :: proc(label: string, flags: ^u32, flags_value: u32) -> bool {
	return CheckboxFlags_UintPtr(semisafe_string_to_cstring(label), flags, flags_value)
}
checkbox_flags_s64_ptr :: proc(label: string, flags: ^i64, flags_value: i64) -> bool {
	return CheckboxFlags_S64Ptr(semisafe_string_to_cstring(label), flags, flags_value)
}
checkbox_flags_u64_ptr :: proc(label: string, flags: ^u64, flags_value: u64) -> bool {
	return CheckboxFlags_U64Ptr(semisafe_string_to_cstring(label), flags, flags_value)
}

radio_button :: proc {
	radio_button_bool,
	radio_button_int_ptr,
}
radio_button_bool :: proc(label: string, active: bool) -> bool {
	return RadioButton_Bool(semisafe_string_to_cstring(label), active)
}
radio_button_int_ptr :: proc(label: string, v: ^i32, v_button: i32) -> bool {
	return RadioButton_IntPtr(semisafe_string_to_cstring(label), v, v_button)
}

progress_bar :: proc(fraction: f32, size_arg: [2]f32 = {-min(f32), 0}, overlay: string = "") {
	ProgressBar(fraction, size_arg, semisafe_string_to_cstring(overlay))
}

bullet :: Bullet

image :: Image

image_button :: proc(str_id: string, user_texture_id: Texture_ID, size: [2]f32, uv0: [2]f32 = {0, 0}, uv1: [2]f32 = {1, 1}, bg_col: [4]f32 = {0, 0, 0, 0}, tint_col: [4]f32 = {1, 1, 1, 1}) -> bool {
	return ImageButton(semisafe_string_to_cstring(str_id), user_texture_id, size, uv0, uv1, bg_col, tint_col)
}

begin_combo :: proc(label: string, preview_value: string, flags: Combo_Flags = {  }) -> bool {
	return BeginCombo(semisafe_string_to_cstring(label), semisafe_string_to_cstring(preview_value), flags)
}

end_combo :: EndCombo

combo :: proc {
	combo_str_arr,
	combo_str,
	combo_fn_bool_ptr,
}
combo_str_arr :: proc(label: string, current_item: ^i32, items: []cstring, popup_max_height_in_items: i32 = -1) -> bool {
	return Combo_Str_arr(semisafe_string_to_cstring(label), current_item, raw_data(items), cast(i32)len(items), popup_max_height_in_items)
}
combo_str :: proc(label: string, current_item: ^i32, items_separated_by_zeros: string, popup_max_height_in_items: i32 = -1) -> bool {
	return Combo_Str(semisafe_string_to_cstring(label), current_item, semisafe_string_to_cstring(items_separated_by_zeros), popup_max_height_in_items)
}
combo_fn_bool_ptr :: proc(label: string, current_item: ^i32, items_getter: #type proc "c"(data: rawptr, idx: i32, out_text: ^cstring) -> bool, data: rawptr, items_count: i32, popup_max_height_in_items: i32 = -1) -> bool {
	return Combo_FnBoolPtr(semisafe_string_to_cstring(label), current_item, items_getter, data, items_count, popup_max_height_in_items)
}

drag_float :: proc(label: string, v: ^f32, v_speed: f32 = 1.0, v_min: f32 = 0.0, v_max: f32 = 0.0, format: string = "%.3f", flags: Slider_Flags = {  }) -> bool {
	return DragFloat(semisafe_string_to_cstring(label), v, v_speed, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

drag_float2 :: proc(label: string, v: [2]f32, v_speed: f32 = 1.0, v_min: f32 = 0.0, v_max: f32 = 0.0, format: string = "%.3f", flags: Slider_Flags = {  }) -> bool {
	return DragFloat2(semisafe_string_to_cstring(label), v, v_speed, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

drag_float3 :: proc(label: string, v: [3]f32, v_speed: f32 = 1.0, v_min: f32 = 0.0, v_max: f32 = 0.0, format: string = "%.3f", flags: Slider_Flags = {  }) -> bool {
	return DragFloat3(semisafe_string_to_cstring(label), v, v_speed, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

drag_float4 :: proc(label: string, v: [4]f32, v_speed: f32 = 1.0, v_min: f32 = 0.0, v_max: f32 = 0.0, format: string = "%.3f", flags: Slider_Flags = {  }) -> bool {
	return DragFloat4(semisafe_string_to_cstring(label), v, v_speed, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

drag_float_range2 :: proc(label: string, v_current_min: ^f32, v_current_max: ^f32, v_speed: f32 = 1.0, v_min: f32 = 0.0, v_max: f32 = 0.0, format: string = "%.3f", format_max: string = "", flags: Slider_Flags = {  }) -> bool {
	return DragFloatRange2(semisafe_string_to_cstring(label), v_current_min, v_current_max, v_speed, v_min, v_max, semisafe_string_to_cstring(format), semisafe_string_to_cstring(format_max), flags)
}

drag_int :: proc(label: string, v: ^i32, v_speed: f32 = 1.0, v_min: i32 = 0, v_max: i32 = 0, format: string = "%d", flags: Slider_Flags = {  }) -> bool {
	return DragInt(semisafe_string_to_cstring(label), v, v_speed, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

drag_int2 :: proc(label: string, v: [2]i32, v_speed: f32 = 1.0, v_min: i32 = 0, v_max: i32 = 0, format: string = "%d", flags: Slider_Flags = {  }) -> bool {
	return DragInt2(semisafe_string_to_cstring(label), v, v_speed, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

drag_int3 :: proc(label: string, v: [3]i32, v_speed: f32 = 1.0, v_min: i32 = 0, v_max: i32 = 0, format: string = "%d", flags: Slider_Flags = {  }) -> bool {
	return DragInt3(semisafe_string_to_cstring(label), v, v_speed, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

drag_int4 :: proc(label: string, v: [4]i32, v_speed: f32 = 1.0, v_min: i32 = 0, v_max: i32 = 0, format: string = "%d", flags: Slider_Flags = {  }) -> bool {
	return DragInt4(semisafe_string_to_cstring(label), v, v_speed, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

drag_int_range2 :: proc(label: string, v_current_min: ^i32, v_current_max: ^i32, v_speed: f32 = 1.0, v_min: i32 = 0, v_max: i32 = 0, format: string = "%d", format_max: string = "", flags: Slider_Flags = {  }) -> bool {
	return DragIntRange2(semisafe_string_to_cstring(label), v_current_min, v_current_max, v_speed, v_min, v_max, semisafe_string_to_cstring(format), semisafe_string_to_cstring(format_max), flags)
}

drag_scalar :: proc(label: string, data_type: Data_Type, p_data: rawptr, v_speed: f32 = 1.0, p_min: rawptr = nil, p_max: rawptr = nil, format: string = "", flags: Slider_Flags = {  }) -> bool {
	return DragScalar(semisafe_string_to_cstring(label), data_type, p_data, v_speed, p_min, p_max, semisafe_string_to_cstring(format), flags)
}

drag_scalar_n :: proc(label: string, data_type: Data_Type, p_data: rawptr, components: i32, v_speed: f32 = 1.0, p_min: rawptr = nil, p_max: rawptr = nil, format: string = "", flags: Slider_Flags = {  }) -> bool {
	return DragScalarN(semisafe_string_to_cstring(label), data_type, p_data, components, v_speed, p_min, p_max, semisafe_string_to_cstring(format), flags)
}

slider_float :: proc(label: string, v: ^f32, v_min: f32, v_max: f32, format: string = "%.3f", flags: Slider_Flags = {  }) -> bool {
	return SliderFloat(semisafe_string_to_cstring(label), v, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

slider_float2 :: proc(label: string, v: [2]f32, v_min: f32, v_max: f32, format: string = "%.3f", flags: Slider_Flags = {  }) -> bool {
	return SliderFloat2(semisafe_string_to_cstring(label), v, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

slider_float3 :: proc(label: string, v: [3]f32, v_min: f32, v_max: f32, format: string = "%.3f", flags: Slider_Flags = {  }) -> bool {
	return SliderFloat3(semisafe_string_to_cstring(label), v, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

slider_float4 :: proc(label: string, v: [4]f32, v_min: f32, v_max: f32, format: string = "%.3f", flags: Slider_Flags = {  }) -> bool {
	return SliderFloat4(semisafe_string_to_cstring(label), v, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

slider_angle :: proc(label: string, v_rad: ^f32, v_degrees_min: f32 = -360.0, v_degrees_max: f32 = +360.0, format: string = "%.0f deg", flags: Slider_Flags = {  }) -> bool {
	return SliderAngle(semisafe_string_to_cstring(label), v_rad, v_degrees_min, v_degrees_max, semisafe_string_to_cstring(format), flags)
}

slider_int :: proc(label: string, v: ^i32, v_min: i32, v_max: i32, format: string = "%d", flags: Slider_Flags = {  }) -> bool {
	return SliderInt(semisafe_string_to_cstring(label), v, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

slider_int2 :: proc(label: string, v: [2]i32, v_min: i32, v_max: i32, format: string = "%d", flags: Slider_Flags = {  }) -> bool {
	return SliderInt2(semisafe_string_to_cstring(label), v, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

slider_int3 :: proc(label: string, v: [3]i32, v_min: i32, v_max: i32, format: string = "%d", flags: Slider_Flags = {  }) -> bool {
	return SliderInt3(semisafe_string_to_cstring(label), v, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

slider_int4 :: proc(label: string, v: [4]i32, v_min: i32, v_max: i32, format: string = "%d", flags: Slider_Flags = {  }) -> bool {
	return SliderInt4(semisafe_string_to_cstring(label), v, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

slider_scalar :: proc(label: string, data_type: Data_Type, p_data: rawptr, p_min: rawptr, p_max: rawptr, format: string = "", flags: Slider_Flags = {  }) -> bool {
	return SliderScalar(semisafe_string_to_cstring(label), data_type, p_data, p_min, p_max, semisafe_string_to_cstring(format), flags)
}

slider_scalar_n :: proc(label: string, data_type: Data_Type, p_data: rawptr, components: i32, p_min: rawptr, p_max: rawptr, format: string = "", flags: Slider_Flags = {  }) -> bool {
	return SliderScalarN(semisafe_string_to_cstring(label), data_type, p_data, components, p_min, p_max, semisafe_string_to_cstring(format), flags)
}

v_slider_float :: proc(label: string, size: [2]f32, v: ^f32, v_min: f32, v_max: f32, format: string = "%.3f", flags: Slider_Flags = {  }) -> bool {
	return VSliderFloat(semisafe_string_to_cstring(label), size, v, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

v_slider_int :: proc(label: string, size: [2]f32, v: ^i32, v_min: i32, v_max: i32, format: string = "%d", flags: Slider_Flags = {  }) -> bool {
	return VSliderInt(semisafe_string_to_cstring(label), size, v, v_min, v_max, semisafe_string_to_cstring(format), flags)
}

v_slider_scalar :: proc(label: string, size: [2]f32, data_type: Data_Type, p_data: rawptr, p_min: rawptr, p_max: rawptr, format: string = "", flags: Slider_Flags = {  }) -> bool {
	return VSliderScalar(semisafe_string_to_cstring(label), size, data_type, p_data, p_min, p_max, semisafe_string_to_cstring(format), flags)
}

input_text :: proc(label: string, buf: []i8, flags: Input_Text_Flags = {  }, callback: Input_Text_Callback = nil, user_data: rawptr = nil) -> bool {
	return InputText(semisafe_string_to_cstring(label), raw_data(buf), len(buf), flags, callback, user_data)
}

input_text_multiline :: proc(label: string, buf: []i8, size: [2]f32 = {0, 0}, flags: Input_Text_Flags = {  }, callback: Input_Text_Callback = nil, user_data: rawptr = nil) -> bool {
	return InputTextMultiline(semisafe_string_to_cstring(label), raw_data(buf), len(buf), size, flags, callback, user_data)
}

input_text_with_hint :: proc(label: string, hint: string, buf: []i8, flags: Input_Text_Flags = {  }, callback: Input_Text_Callback = nil, user_data: rawptr = nil) -> bool {
	return InputTextWithHint(semisafe_string_to_cstring(label), semisafe_string_to_cstring(hint), raw_data(buf), len(buf), flags, callback, user_data)
}

input_float :: proc(label: string, v: ^f32, step: f32 = 0.0, step_fast: f32 = 0.0, format: string = "%.3f", flags: Input_Text_Flags = {  }) -> bool {
	return InputFloat(semisafe_string_to_cstring(label), v, step, step_fast, semisafe_string_to_cstring(format), flags)
}

input_float2 :: proc(label: string, v: [2]f32, format: string = "%.3f", flags: Input_Text_Flags = {  }) -> bool {
	return InputFloat2(semisafe_string_to_cstring(label), v, semisafe_string_to_cstring(format), flags)
}

input_float3 :: proc(label: string, v: [3]f32, format: string = "%.3f", flags: Input_Text_Flags = {  }) -> bool {
	return InputFloat3(semisafe_string_to_cstring(label), v, semisafe_string_to_cstring(format), flags)
}

input_float4 :: proc(label: string, v: [4]f32, format: string = "%.3f", flags: Input_Text_Flags = {  }) -> bool {
	return InputFloat4(semisafe_string_to_cstring(label), v, semisafe_string_to_cstring(format), flags)
}

input_int :: proc(label: string, v: ^i32, step: i32 = 1, step_fast: i32 = 100, flags: Input_Text_Flags = {  }) -> bool {
	return InputInt(semisafe_string_to_cstring(label), v, step, step_fast, flags)
}

input_int2 :: proc(label: string, v: [2]i32, flags: Input_Text_Flags = {  }) -> bool {
	return InputInt2(semisafe_string_to_cstring(label), v, flags)
}

input_int3 :: proc(label: string, v: [3]i32, flags: Input_Text_Flags = {  }) -> bool {
	return InputInt3(semisafe_string_to_cstring(label), v, flags)
}

input_int4 :: proc(label: string, v: [4]i32, flags: Input_Text_Flags = {  }) -> bool {
	return InputInt4(semisafe_string_to_cstring(label), v, flags)
}

input_double :: proc(label: string, v: ^f64, step: f64 = 0.0, step_fast: f64 = 0.0, format: string = "%.6f", flags: Input_Text_Flags = {  }) -> bool {
	return InputDouble(semisafe_string_to_cstring(label), v, step, step_fast, semisafe_string_to_cstring(format), flags)
}

input_scalar :: proc(label: string, data_type: Data_Type, p_data: rawptr, p_step: rawptr = nil, p_step_fast: rawptr = nil, format: string = "", flags: Input_Text_Flags = {  }) -> bool {
	return InputScalar(semisafe_string_to_cstring(label), data_type, p_data, p_step, p_step_fast, semisafe_string_to_cstring(format), flags)
}

input_scalar_n :: proc(label: string, data_type: Data_Type, p_data: rawptr, components: i32, p_step: rawptr = nil, p_step_fast: rawptr = nil, format: string = "", flags: Input_Text_Flags = {  }) -> bool {
	return InputScalarN(semisafe_string_to_cstring(label), data_type, p_data, components, p_step, p_step_fast, semisafe_string_to_cstring(format), flags)
}

color_edit3 :: proc(label: string, col: [3]f32, flags: Color_Edit_Flags = {  }) -> bool {
	return ColorEdit3(semisafe_string_to_cstring(label), col, flags)
}

color_edit4 :: proc(label: string, col: [4]f32, flags: Color_Edit_Flags = {  }) -> bool {
	return ColorEdit4(semisafe_string_to_cstring(label), col, flags)
}

color_picker3 :: proc(label: string, col: [3]f32, flags: Color_Edit_Flags = {  }) -> bool {
	return ColorPicker3(semisafe_string_to_cstring(label), col, flags)
}

color_picker4 :: proc(label: string, col: [4]f32, flags: Color_Edit_Flags = {  }, ref_col: ^f32 = nil) -> bool {
	return ColorPicker4(semisafe_string_to_cstring(label), col, flags, ref_col)
}

color_button :: proc(desc_id: string, col: [4]f32, flags: Color_Edit_Flags = {  }, size: [2]f32 = {0, 0}) -> bool {
	return ColorButton(semisafe_string_to_cstring(desc_id), col, flags, size)
}

set_color_edit_options :: SetColorEditOptions

tree_node :: proc {
	tree_node_str,
	tree_node_str_str,
	tree_node_ptr,
}
tree_node_str :: proc(label: string) -> bool {
	return TreeNode_Str(semisafe_string_to_cstring(label))
}
tree_node_str_str :: proc(str_id: string, fmt_: string, _args_: ..any) -> bool {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	return TreeNode_StrStr(semisafe_string_to_cstring(str_id), "%s", cstring(raw_data(_fmt_sb.buf)))
}
tree_node_ptr :: proc(ptr_id: rawptr, fmt_: string, _args_: ..any) -> bool {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	return TreeNode_Ptr(ptr_id, "%s", cstring(raw_data(_fmt_sb.buf)))
}

tree_node_ex :: proc {
	tree_node_ex_str,
	tree_node_ex_str_str,
	tree_node_ex_ptr,
}
tree_node_ex_str :: proc(label: string, flags: Tree_Node_Flags = {  }) -> bool {
	return TreeNodeEx_Str(semisafe_string_to_cstring(label), flags)
}
tree_node_ex_str_str :: proc(str_id: string, flags: Tree_Node_Flags, fmt_: string, _args_: ..any) -> bool {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	return TreeNodeEx_StrStr(semisafe_string_to_cstring(str_id), flags, "%s", cstring(raw_data(_fmt_sb.buf)))
}
tree_node_ex_ptr :: proc(ptr_id: rawptr, flags: Tree_Node_Flags, fmt_: string, _args_: ..any) -> bool {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	return TreeNodeEx_Ptr(ptr_id, flags, "%s", cstring(raw_data(_fmt_sb.buf)))
}

tree_push :: proc {
	tree_push_str,
	tree_push_ptr,
}
tree_push_str :: proc(str_id: string) {
	TreePush_Str(semisafe_string_to_cstring(str_id))
}
tree_push_ptr :: TreePush_Ptr

tree_pop :: TreePop

get_tree_node_to_label_spacing :: GetTreeNodeToLabelSpacing

collapsing_header :: proc {
	collapsing_header_tree_node_flags,
	collapsing_header_bool_ptr,
}
collapsing_header_tree_node_flags :: proc(label: string, flags: Tree_Node_Flags = {  }) -> bool {
	return CollapsingHeader_TreeNodeFlags(semisafe_string_to_cstring(label), flags)
}
collapsing_header_bool_ptr :: proc(label: string, p_visible: ^bool, flags: Tree_Node_Flags = {  }) -> bool {
	return CollapsingHeader_BoolPtr(semisafe_string_to_cstring(label), p_visible, flags)
}

set_next_item_open :: SetNextItemOpen

selectable :: proc {
	selectable_bool,
	selectable_bool_ptr,
}
selectable_bool :: proc(label: string, selected: bool = false, flags: Selectable_Flags = {  }, size: [2]f32 = {0, 0}) -> bool {
	return Selectable_Bool(semisafe_string_to_cstring(label), selected, flags, size)
}
selectable_bool_ptr :: proc(label: string, p_selected: ^bool, flags: Selectable_Flags = {  }, size: [2]f32 = {0, 0}) -> bool {
	return Selectable_BoolPtr(semisafe_string_to_cstring(label), p_selected, flags, size)
}

begin_list_box :: proc(label: string, size: [2]f32 = {0, 0}) -> bool {
	return BeginListBox(semisafe_string_to_cstring(label), size)
}

end_list_box :: EndListBox

list_box :: proc {
	list_box_str_arr,
	list_box_fn_bool_ptr,
}
list_box_str_arr :: proc(label: string, current_item: ^i32, items: []cstring, height_in_items: i32 = -1) -> bool {
	return ListBox_Str_arr(semisafe_string_to_cstring(label), current_item, raw_data(items), cast(i32)len(items), height_in_items)
}
list_box_fn_bool_ptr :: proc(label: string, current_item: ^i32, items_getter: #type proc "c"(data: rawptr, idx: i32, out_text: ^cstring) -> bool, data: rawptr, items_count: i32, height_in_items: i32 = -1) -> bool {
	return ListBox_FnBoolPtr(semisafe_string_to_cstring(label), current_item, items_getter, data, items_count, height_in_items)
}

plot_lines :: proc {
	plot_lines_float_ptr,
	plot_lines_fn_float_ptr,
}
plot_lines_float_ptr :: proc(label: string, values: []f32, values_offset: i32 = 0, overlay_text: string = "", scale_min: f32 = max(f32), scale_max: f32 = max(f32), graph_size: [2]f32 = {0, 0}, stride: i32 = size_of(f32)) {
	PlotLines_FloatPtr(semisafe_string_to_cstring(label), raw_data(values), cast(i32)len(values), values_offset, semisafe_string_to_cstring(overlay_text), scale_min, scale_max, graph_size, stride)
}
plot_lines_fn_float_ptr :: proc(label: string, values_getter: #type proc "c"(data: rawptr, idx: i32) -> f32, data: rawptr, values_count: i32, values_offset: i32 = 0, overlay_text: string = "", scale_min: f32 = max(f32), scale_max: f32 = max(f32), graph_size: [2]f32 = {0, 0}) {
	PlotLines_FnFloatPtr(semisafe_string_to_cstring(label), values_getter, data, values_count, values_offset, semisafe_string_to_cstring(overlay_text), scale_min, scale_max, graph_size)
}

plot_histogram :: proc {
	plot_histogram_float_ptr,
	plot_histogram_fn_float_ptr,
}
plot_histogram_float_ptr :: proc(label: string, values: []f32, values_offset: i32 = 0, overlay_text: string = "", scale_min: f32 = max(f32), scale_max: f32 = max(f32), graph_size: [2]f32 = {0, 0}, stride: i32 = size_of(f32)) {
	PlotHistogram_FloatPtr(semisafe_string_to_cstring(label), raw_data(values), cast(i32)len(values), values_offset, semisafe_string_to_cstring(overlay_text), scale_min, scale_max, graph_size, stride)
}
plot_histogram_fn_float_ptr :: proc(label: string, values_getter: #type proc "c"(data: rawptr, idx: i32) -> f32, data: rawptr, values_count: i32, values_offset: i32 = 0, overlay_text: string = "", scale_min: f32 = max(f32), scale_max: f32 = max(f32), graph_size: [2]f32 = {0, 0}) {
	PlotHistogram_FnFloatPtr(semisafe_string_to_cstring(label), values_getter, data, values_count, values_offset, semisafe_string_to_cstring(overlay_text), scale_min, scale_max, graph_size)
}

value :: proc {
	value_bool,
	value_int,
	value_uint,
	value_float,
}
value_bool :: proc(prefix: string, b: bool) {
	Value_Bool(semisafe_string_to_cstring(prefix), b)
}
value_int :: proc(prefix: string, v: i32) {
	Value_Int(semisafe_string_to_cstring(prefix), v)
}
value_uint :: proc(prefix: string, v: u32) {
	Value_Uint(semisafe_string_to_cstring(prefix), v)
}
value_float :: proc(prefix: string, v: f32, float_format: string = "") {
	Value_Float(semisafe_string_to_cstring(prefix), v, semisafe_string_to_cstring(float_format))
}

begin_menu_bar :: BeginMenuBar

end_menu_bar :: EndMenuBar

begin_main_menu_bar :: BeginMainMenuBar

end_main_menu_bar :: EndMainMenuBar

begin_menu :: proc(label: string, enabled: bool = true) -> bool {
	return BeginMenu(semisafe_string_to_cstring(label), enabled)
}

end_menu :: EndMenu

menu_item :: proc {
	menu_item_bool,
	menu_item_bool_ptr,
}
menu_item_bool :: proc(label: string, shortcut: string = "", selected: bool = false, enabled: bool = true) -> bool {
	return MenuItem_Bool(semisafe_string_to_cstring(label), semisafe_string_to_cstring(shortcut), selected, enabled)
}
menu_item_bool_ptr :: proc(label: string, shortcut: string, p_selected: ^bool, enabled: bool = true) -> bool {
	return MenuItem_BoolPtr(semisafe_string_to_cstring(label), semisafe_string_to_cstring(shortcut), p_selected, enabled)
}

begin_tooltip :: BeginTooltip

end_tooltip :: EndTooltip

set_tooltip :: proc(fmt_: string, _args_: ..any) {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	SetTooltip("%s", cstring(raw_data(_fmt_sb.buf)))
}

begin_item_tooltip :: BeginItemTooltip

set_item_tooltip :: proc(fmt_: string, _args_: ..any) {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	SetItemTooltip("%s", cstring(raw_data(_fmt_sb.buf)))
}

begin_popup :: proc(str_id: string, flags: Window_Flags = {  }) -> bool {
	return BeginPopup(semisafe_string_to_cstring(str_id), flags)
}

begin_popup_modal :: proc(name: string, p_open: ^bool = nil, flags: Window_Flags = {  }) -> bool {
	return BeginPopupModal(semisafe_string_to_cstring(name), p_open, flags)
}

end_popup :: EndPopup

open_popup :: proc {
	open_popup_str,
	open_popup_id,
}
open_popup_str :: proc(str_id: string, popup_flags: Popup_Flags = {  }) {
	OpenPopup_Str(semisafe_string_to_cstring(str_id), popup_flags)
}
open_popup_id :: OpenPopup_ID

open_popup_on_item_click :: proc(str_id: string = "", popup_flags: Popup_Flags = {  }) {
	OpenPopupOnItemClick(semisafe_string_to_cstring(str_id), popup_flags)
}

close_current_popup :: CloseCurrentPopup

begin_popup_context_item :: proc(str_id: string = "", popup_flags: Popup_Flags = {  }) -> bool {
	return BeginPopupContextItem(semisafe_string_to_cstring(str_id), popup_flags)
}

begin_popup_context_window :: proc(str_id: string = "", popup_flags: Popup_Flags = {  }) -> bool {
	return BeginPopupContextWindow(semisafe_string_to_cstring(str_id), popup_flags)
}

begin_popup_context_void :: proc(str_id: string = "", popup_flags: Popup_Flags = {  }) -> bool {
	return BeginPopupContextVoid(semisafe_string_to_cstring(str_id), popup_flags)
}

is_popup_open :: proc {
	is_popup_open_str,
	is_popup_open_id,
}
is_popup_open_str :: proc(str_id: string, flags: Popup_Flags = {  }) -> bool {
	return IsPopupOpen_Str(semisafe_string_to_cstring(str_id), flags)
}
is_popup_open_id :: IsPopupOpen_ID

begin_table :: proc(str_id: string, column: i32, flags: Table_Flags = {  }, outer_size: [2]f32 = {0.0, 0.0}, inner_width: f32 = 0.0) -> bool {
	return BeginTable(semisafe_string_to_cstring(str_id), column, flags, outer_size, inner_width)
}

end_table :: EndTable

table_next_row :: TableNextRow

table_next_column :: TableNextColumn

table_set_column_index :: TableSetColumnIndex

table_setup_column :: proc(label: string, flags: Table_Column_Flags = {  }, init_width_or_weight: f32 = 0.0, user_id: ID = 0) {
	TableSetupColumn(semisafe_string_to_cstring(label), flags, init_width_or_weight, user_id)
}

table_setup_scroll_freeze :: TableSetupScrollFreeze

table_headers_row :: TableHeadersRow

table_header :: proc(label: string) {
	TableHeader(semisafe_string_to_cstring(label))
}

table_get_sort_specs :: TableGetSortSpecs

table_get_column_count :: TableGetColumnCount

table_get_column_index :: TableGetColumnIndex

table_get_row_index :: TableGetRowIndex

table_get_column_name :: proc {
	table_get_column_name_int,
	table_get_column_name_table_ptr,
}
table_get_column_name_int :: TableGetColumnName_Int
table_get_column_name_table_ptr :: TableGetColumnName_TablePtr

table_get_column_flags :: TableGetColumnFlags

table_set_column_enabled :: TableSetColumnEnabled

table_set_bg_color :: TableSetBgColor

columns :: proc(count: i32 = 1, id: string = "", border: bool = true) {
	Columns(count, semisafe_string_to_cstring(id), border)
}

next_column :: NextColumn

get_column_index :: GetColumnIndex

get_column_width :: GetColumnWidth

set_column_width :: SetColumnWidth

get_column_offset :: GetColumnOffset

set_column_offset :: SetColumnOffset

get_columns_count :: GetColumnsCount

begin_tab_bar :: proc(str_id: string, flags: Tab_Bar_Flags = {  }) -> bool {
	return BeginTabBar(semisafe_string_to_cstring(str_id), flags)
}

end_tab_bar :: EndTabBar

begin_tab_item :: proc(label: string, p_open: ^bool = nil, flags: Tab_Item_Flags = {  }) -> bool {
	return BeginTabItem(semisafe_string_to_cstring(label), p_open, flags)
}

end_tab_item :: EndTabItem

tab_item_button :: proc(label: string, flags: Tab_Item_Flags = {  }) -> bool {
	return TabItemButton(semisafe_string_to_cstring(label), flags)
}

set_tab_item_closed :: proc(tab_or_docked_window_label: string) {
	SetTabItemClosed(semisafe_string_to_cstring(tab_or_docked_window_label))
}

dock_space :: DockSpace

dock_space_over_viewport :: DockSpaceOverViewport

set_next_window_dock_id :: SetNextWindowDockID

set_next_window_class :: SetNextWindowClass

get_window_dock_id :: GetWindowDockID

is_window_docked :: IsWindowDocked

log_to_tty :: LogToTTY

log_to_file :: proc(auto_open_depth: i32 = -1, filename: string = "") {
	LogToFile(auto_open_depth, semisafe_string_to_cstring(filename))
}

log_to_clipboard :: LogToClipboard

log_finish :: LogFinish

log_buttons :: LogButtons

begin_drag_drop_source :: BeginDragDropSource

set_drag_drop_payload :: proc(type: string, data: rawptr, sz: int, cond: Cond = {  }) -> bool {
	return SetDragDropPayload(semisafe_string_to_cstring(type), data, sz, cond)
}

end_drag_drop_source :: EndDragDropSource

begin_drag_drop_target :: BeginDragDropTarget

accept_drag_drop_payload :: proc(type: string, flags: Drag_Drop_Flags = {  }) -> ^Payload {
	return AcceptDragDropPayload(semisafe_string_to_cstring(type), flags)
}

end_drag_drop_target :: EndDragDropTarget

get_drag_drop_payload :: GetDragDropPayload

begin_disabled :: BeginDisabled

end_disabled :: EndDisabled

push_clip_rect :: PushClipRect

pop_clip_rect :: PopClipRect

set_item_default_focus :: SetItemDefaultFocus

set_keyboard_focus_here :: SetKeyboardFocusHere

set_next_item_allow_overlap :: SetNextItemAllowOverlap

is_item_hovered :: IsItemHovered

is_item_active :: IsItemActive

is_item_focused :: IsItemFocused

is_item_clicked :: IsItemClicked

is_item_visible :: IsItemVisible

is_item_edited :: IsItemEdited

is_item_activated :: IsItemActivated

is_item_deactivated :: IsItemDeactivated

is_item_deactivated_after_edit :: IsItemDeactivatedAfterEdit

is_item_toggled_open :: IsItemToggledOpen

is_any_item_hovered :: IsAnyItemHovered

is_any_item_active :: IsAnyItemActive

is_any_item_focused :: IsAnyItemFocused

get_item_id :: GetItemID

get_item_rect_min :: proc() -> (p_out: [2]f32) {
	GetItemRectMin(&p_out)
	return
}

get_item_rect_max :: proc() -> (p_out: [2]f32) {
	GetItemRectMax(&p_out)
	return
}

get_item_rect_size :: proc() -> (p_out: [2]f32) {
	GetItemRectSize(&p_out)
	return
}

get_main_viewport :: GetMainViewport

get_background_draw_list :: proc {
	get_background_draw_list_nil,
	get_background_draw_list_viewport_ptr,
}
get_background_draw_list_nil :: GetBackgroundDrawList_Nil
get_background_draw_list_viewport_ptr :: GetBackgroundDrawList_ViewportPtr

get_foreground_draw_list :: proc {
	get_foreground_draw_list_nil,
	get_foreground_draw_list_viewport_ptr,
	get_foreground_draw_list_window_ptr,
}
get_foreground_draw_list_nil :: GetForegroundDrawList_Nil
get_foreground_draw_list_viewport_ptr :: GetForegroundDrawList_ViewportPtr
get_foreground_draw_list_window_ptr :: GetForegroundDrawList_WindowPtr

is_rect_visible :: proc {
	is_rect_visible_nil,
	is_rect_visible_vec2,
}
is_rect_visible_nil :: IsRectVisible_Nil
is_rect_visible_vec2 :: IsRectVisible_Vec2

get_time :: GetTime

get_frame_count :: GetFrameCount

get_draw_list_shared_data :: GetDrawListSharedData

get_style_color_name :: GetStyleColorName

set_state_storage :: SetStateStorage

get_state_storage :: GetStateStorage

begin_child_frame :: BeginChildFrame

end_child_frame :: EndChildFrame

calc_text_size :: proc(text: string, hide_text_after_double_hash: bool = false, wrap_width: f32 = -1.0) -> (p_out: [2]f32) {
	CalcTextSize(&p_out, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))), hide_text_after_double_hash, wrap_width)
	return
}

color_convert_u32_to_float4 :: proc(in_: u32) -> (p_out: [4]f32) {
	ColorConvertU32ToFloat4(&p_out, in_)
	return
}

color_convert_float4_to_u32 :: ColorConvertFloat4ToU32

color_convert_rgbto_hsv :: proc(r: f32, g: f32, b: f32) -> (out_h: f32, out_s: f32, out_v: f32) {
	ColorConvertRGBtoHSV(r, g, b, &out_h, &out_s, &out_v)
	return
}

color_convert_hsvto_rgb :: proc(h: f32, s: f32, v: f32) -> (out_r: f32, out_g: f32, out_b: f32) {
	ColorConvertHSVtoRGB(h, s, v, &out_r, &out_g, &out_b)
	return
}

is_key_down :: proc {
	is_key_down_nil,
	is_key_down_id,
}
is_key_down_nil :: IsKeyDown_Nil
is_key_down_id :: IsKeyDown_ID

is_key_pressed :: proc {
	is_key_pressed_bool,
	is_key_pressed_id,
}
is_key_pressed_bool :: IsKeyPressed_Bool
is_key_pressed_id :: IsKeyPressed_ID

is_key_released :: proc {
	is_key_released_nil,
	is_key_released_id,
}
is_key_released_nil :: IsKeyReleased_Nil
is_key_released_id :: IsKeyReleased_ID

get_key_pressed_amount :: GetKeyPressedAmount

get_key_name :: GetKeyName

set_next_frame_want_capture_keyboard :: SetNextFrameWantCaptureKeyboard

is_mouse_down :: proc {
	is_mouse_down_nil,
	is_mouse_down_id,
}
is_mouse_down_nil :: IsMouseDown_Nil
is_mouse_down_id :: IsMouseDown_ID

is_mouse_clicked :: proc {
	is_mouse_clicked_bool,
	is_mouse_clicked_id,
}
is_mouse_clicked_bool :: IsMouseClicked_Bool
is_mouse_clicked_id :: IsMouseClicked_ID

is_mouse_released :: proc {
	is_mouse_released_nil,
	is_mouse_released_id,
}
is_mouse_released_nil :: IsMouseReleased_Nil
is_mouse_released_id :: IsMouseReleased_ID

is_mouse_double_clicked :: IsMouseDoubleClicked

get_mouse_clicked_count :: GetMouseClickedCount

is_mouse_hovering_rect :: IsMouseHoveringRect

is_mouse_pos_valid :: IsMousePosValid

is_any_mouse_down :: IsAnyMouseDown

get_mouse_pos :: proc() -> (p_out: [2]f32) {
	GetMousePos(&p_out)
	return
}

get_mouse_pos_on_opening_current_popup :: proc() -> (p_out: [2]f32) {
	GetMousePosOnOpeningCurrentPopup(&p_out)
	return
}

is_mouse_dragging :: IsMouseDragging

get_mouse_drag_delta :: proc(button: Mouse_Button = .Left, lock_threshold: f32 = -1.0) -> (p_out: [2]f32) {
	GetMouseDragDelta(&p_out, button, lock_threshold)
	return
}

reset_mouse_drag_delta :: ResetMouseDragDelta

get_mouse_cursor :: GetMouseCursor

set_mouse_cursor :: SetMouseCursor

set_next_frame_want_capture_mouse :: SetNextFrameWantCaptureMouse

get_clipboard_text :: GetClipboardText

set_clipboard_text :: proc(text: string) {
	SetClipboardText(semisafe_string_to_cstring(text))
}

load_ini_settings_from_disk :: proc(ini_filename: string) {
	LoadIniSettingsFromDisk(semisafe_string_to_cstring(ini_filename))
}

load_ini_settings_from_memory :: proc(ini_data: string, ini_size: int = 0) {
	LoadIniSettingsFromMemory(semisafe_string_to_cstring(ini_data), ini_size)
}

save_ini_settings_to_disk :: proc(ini_filename: string) {
	SaveIniSettingsToDisk(semisafe_string_to_cstring(ini_filename))
}

save_ini_settings_to_memory :: proc() -> (orig_ret: cstring, out_ini_size: int) {
	orig_ret = SaveIniSettingsToMemory(&out_ini_size)
	return
}

debug_text_encoding :: proc(text: string) {
	DebugTextEncoding(semisafe_string_to_cstring(text))
}

debug_check_version_and_data_layout :: proc(version_str: string, sz_io: int, sz_style: int, sz_vec2: int, sz_vec4: int, sz_drawvert: int, sz_drawidx: int) -> bool {
	return DebugCheckVersionAndDataLayout(semisafe_string_to_cstring(version_str), sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert, sz_drawidx)
}

set_allocator_functions :: SetAllocatorFunctions

get_allocator_functions :: GetAllocatorFunctions

get_platform_io :: GetPlatformIO

update_platform_windows :: UpdatePlatformWindows

render_platform_windows_default :: RenderPlatformWindowsDefault

destroy_platform_windows :: DestroyPlatformWindows

find_viewport_by_id :: FindViewportByID

find_viewport_by_platform_handle :: FindViewportByPlatformHandle

style_new :: Style_new

style_destroy :: Style_destroy

style_scale_all_sizes :: Style_ScaleAllSizes

io_add_key_event :: IO_AddKeyEvent

io_add_key_analog_event :: IO_AddKeyAnalogEvent

io_add_mouse_pos_event :: IO_AddMousePosEvent

io_add_mouse_button_event :: IO_AddMouseButtonEvent

io_add_mouse_wheel_event :: IO_AddMouseWheelEvent

io_add_mouse_source_event :: IO_AddMouseSourceEvent

io_add_mouse_viewport_event :: IO_AddMouseViewportEvent

io_add_focus_event :: IO_AddFocusEvent

io_add_input_character :: IO_AddInputCharacter

io_add_input_character_u_t_f16 :: IO_AddInputCharacterUTF16

io_add_input_characters_u_t_f8 :: proc(self: ^IO, str: string) {
	IO_AddInputCharactersUTF8(self, semisafe_string_to_cstring(str))
}

io_set_key_event_native_data :: IO_SetKeyEventNativeData

io_set_app_accepting_events :: IO_SetAppAcceptingEvents

io_clear_events_queue :: IO_ClearEventsQueue

io_clear_input_keys :: IO_ClearInputKeys

io_new :: IO_new

io_destroy :: IO_destroy

input_text_callback_data_new :: InputTextCallbackData_new

input_text_callback_data_destroy :: InputTextCallbackData_destroy

input_text_callback_data_delete_chars :: InputTextCallbackData_DeleteChars

input_text_callback_data_insert_chars :: proc(self: ^Input_Text_Callback_Data, pos: i32, text: string) {
	InputTextCallbackData_InsertChars(self, pos, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))))
}

input_text_callback_data_select_all :: InputTextCallbackData_SelectAll

input_text_callback_data_clear_selection :: InputTextCallbackData_ClearSelection

input_text_callback_data_has_selection :: InputTextCallbackData_HasSelection

window_class_new :: WindowClass_new

window_class_destroy :: WindowClass_destroy

payload_new :: Payload_new

payload_destroy :: Payload_destroy

payload_clear :: Payload_Clear

payload_is_data_type :: proc(self: ^Payload, type: string) -> bool {
	return Payload_IsDataType(self, semisafe_string_to_cstring(type))
}

payload_is_preview :: Payload_IsPreview

payload_is_delivery :: Payload_IsDelivery

table_column_sort_specs_new :: TableColumnSortSpecs_new

table_column_sort_specs_destroy :: TableColumnSortSpecs_destroy

table_sort_specs_new :: TableSortSpecs_new

table_sort_specs_destroy :: TableSortSpecs_destroy

once_upon_a_frame_new :: OnceUponAFrame_new

once_upon_a_frame_destroy :: OnceUponAFrame_destroy

text_filter_new :: proc(default_filter: string) -> ^Text_Filter {
	return TextFilter_new(semisafe_string_to_cstring(default_filter))
}

text_filter_destroy :: TextFilter_destroy

text_filter_draw :: proc(self: ^Text_Filter, label: string = "Filter (inc,-exc)", width: f32 = 0.0) -> bool {
	return TextFilter_Draw(self, semisafe_string_to_cstring(label), width)
}

text_filter_pass_filter :: proc(self: ^Text_Filter, text: string) -> bool {
	return TextFilter_PassFilter(self, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))))
}

text_filter_build :: TextFilter_Build

text_filter_clear :: TextFilter_Clear

text_filter_is_active :: TextFilter_IsActive

text_range_new :: proc {
	text_range_new_nil,
	text_range_new_str,
}
text_range_new_nil :: TextRange_TextRange_Nil
text_range_new_str :: proc(_b: string, _e: string) -> ^Text_Range {
	return TextRange_TextRange_Str(semisafe_string_to_cstring(_b), semisafe_string_to_cstring(_e))
}

text_range_destroy :: TextRange_destroy

text_range_empty :: TextRange_empty

text_range_split :: TextRange_split

text_buffer_new :: TextBuffer_new

text_buffer_destroy :: TextBuffer_destroy

text_buffer_begin :: TextBuffer_begin

text_buffer_end :: TextBuffer_end

text_buffer_size :: TextBuffer_size

text_buffer_empty :: TextBuffer_empty

text_buffer_clear :: TextBuffer_clear

text_buffer_reserve :: TextBuffer_reserve

text_buffer_c_str :: TextBuffer_c_str

text_buffer_append :: proc(self: ^Text_Buffer, str: string) {
	TextBuffer_append(self, raw_data(str), cast([^]u8) (uintptr(raw_data(str)) + uintptr(len(str))))
}

storage_pair_new :: proc {
	storage_pair_new_int,
	storage_pair_new_float,
	storage_pair_new_ptr,
}
storage_pair_new_int :: StoragePair_StoragePair_Int
storage_pair_new_float :: StoragePair_StoragePair_Float
storage_pair_new_ptr :: StoragePair_StoragePair_Ptr

storage_pair_destroy :: StoragePair_destroy

storage_clear :: Storage_Clear

storage_get_int :: Storage_GetInt

storage_set_int :: Storage_SetInt

storage_get_bool :: Storage_GetBool

storage_set_bool :: Storage_SetBool

storage_get_float :: Storage_GetFloat

storage_set_float :: Storage_SetFloat

storage_get_void_ptr :: Storage_GetVoidPtr

storage_set_void_ptr :: Storage_SetVoidPtr

storage_get_int_ref :: Storage_GetIntRef

storage_get_bool_ref :: Storage_GetBoolRef

storage_get_float_ref :: Storage_GetFloatRef

storage_get_void_ptr_ref :: Storage_GetVoidPtrRef

storage_set_all_int :: Storage_SetAllInt

storage_build_sort_by_key :: Storage_BuildSortByKey

list_clipper_new :: ListClipper_new

list_clipper_destroy :: ListClipper_destroy

list_clipper_begin :: ListClipper_Begin

list_clipper_end :: ListClipper_End

list_clipper_step :: ListClipper_Step

list_clipper_include_range_by_indices :: ListClipper_IncludeRangeByIndices

color_new :: proc {
	color_new_nil,
	color_new_float,
	color_new_vec4,
	color_new_int,
	color_new_u32,
}
color_new_nil :: Color_Color_Nil
color_new_float :: Color_Color_Float
color_new_vec4 :: Color_Color_Vec4
color_new_int :: Color_Color_Int
color_new_u32 :: Color_Color_U32

color_destroy :: Color_destroy

color_set_hsv :: Color_SetHSV

color_hsv :: proc(h: f32, s: f32, v: f32, a: f32) -> (p_out: Color) {
	Color_HSV(&p_out, h, s, v, a)
	return
}

draw_cmd_new :: DrawCmd_new

draw_cmd_destroy :: DrawCmd_destroy

draw_cmd_get_tex_id :: DrawCmd_GetTexID

draw_list_splitter_new :: DrawListSplitter_new

draw_list_splitter_destroy :: DrawListSplitter_destroy

draw_list_splitter_clear :: DrawListSplitter_Clear

draw_list_splitter_clear_free_memory :: DrawListSplitter_ClearFreeMemory

draw_list_splitter_split :: DrawListSplitter_Split

draw_list_splitter_merge :: DrawListSplitter_Merge

draw_list_splitter_set_current_channel :: DrawListSplitter_SetCurrentChannel

draw_list_new :: DrawList_new

draw_list_destroy :: DrawList_destroy

draw_list_push_clip_rect :: DrawList_PushClipRect

draw_list_push_clip_rect_full_screen :: DrawList_PushClipRectFullScreen

draw_list_pop_clip_rect :: DrawList_PopClipRect

draw_list_push_texture_id :: DrawList_PushTextureID

draw_list_pop_texture_id :: DrawList_PopTextureID

draw_list_get_clip_rect_min :: proc(self: ^Draw_List) -> (p_out: [2]f32) {
	DrawList_GetClipRectMin(&p_out, self)
	return
}

draw_list_get_clip_rect_max :: proc(self: ^Draw_List) -> (p_out: [2]f32) {
	DrawList_GetClipRectMax(&p_out, self)
	return
}

draw_list_add_line :: DrawList_AddLine

draw_list_add_rect :: DrawList_AddRect

draw_list_add_rect_filled :: DrawList_AddRectFilled

draw_list_add_rect_filled_multi_color :: DrawList_AddRectFilledMultiColor

draw_list_add_quad :: DrawList_AddQuad

draw_list_add_quad_filled :: DrawList_AddQuadFilled

draw_list_add_triangle :: DrawList_AddTriangle

draw_list_add_triangle_filled :: DrawList_AddTriangleFilled

draw_list_add_circle :: DrawList_AddCircle

draw_list_add_circle_filled :: DrawList_AddCircleFilled

draw_list_add_ngon :: DrawList_AddNgon

draw_list_add_ngon_filled :: DrawList_AddNgonFilled

draw_list_add_text :: proc {
	draw_list_add_text_vec2,
	draw_list_add_text_font_ptr,
}
draw_list_add_text_vec2 :: proc(self: ^Draw_List, pos: [2]f32, col: u32, text: string) {
	DrawList_AddText_Vec2(self, pos, col, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))))
}
draw_list_add_text_font_ptr :: proc(self: ^Draw_List, font: ^Font, font_size: f32, pos: [2]f32, col: u32, text: string, wrap_width: f32 = 0.0, cpu_fine_clip_rect: ^[4]f32 = nil) {
	DrawList_AddText_FontPtr(self, font, font_size, pos, col, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))), wrap_width, cpu_fine_clip_rect)
}

draw_list_add_polyline :: DrawList_AddPolyline

draw_list_add_convex_poly_filled :: DrawList_AddConvexPolyFilled

draw_list_add_bezier_cubic :: DrawList_AddBezierCubic

draw_list_add_bezier_quadratic :: DrawList_AddBezierQuadratic

draw_list_add_image :: DrawList_AddImage

draw_list_add_image_quad :: DrawList_AddImageQuad

draw_list_add_image_rounded :: DrawList_AddImageRounded

draw_list_path_clear :: DrawList_PathClear

draw_list_path_line_to :: DrawList_PathLineTo

draw_list_path_line_to_merge_duplicate :: DrawList_PathLineToMergeDuplicate

draw_list_path_fill_convex :: DrawList_PathFillConvex

draw_list_path_stroke :: DrawList_PathStroke

draw_list_path_arc_to :: DrawList_PathArcTo

draw_list_path_arc_to_fast :: DrawList_PathArcToFast

draw_list_path_bezier_cubic_curve_to :: DrawList_PathBezierCubicCurveTo

draw_list_path_bezier_quadratic_curve_to :: DrawList_PathBezierQuadraticCurveTo

draw_list_path_rect :: DrawList_PathRect

draw_list_add_callback :: DrawList_AddCallback

draw_list_add_draw_cmd :: DrawList_AddDrawCmd

draw_list_clone_output :: DrawList_CloneOutput

draw_list_channels_split :: DrawList_ChannelsSplit

draw_list_channels_merge :: DrawList_ChannelsMerge

draw_list_channels_set_current :: DrawList_ChannelsSetCurrent

draw_list_prim_reserve :: DrawList_PrimReserve

draw_list_prim_unreserve :: DrawList_PrimUnreserve

draw_list_prim_rect :: DrawList_PrimRect

draw_list_prim_rect_uv :: DrawList_PrimRectUV

draw_list_prim_quad_uv :: DrawList_PrimQuadUV

draw_list_prim_write_vtx :: DrawList_PrimWriteVtx

draw_list_prim_write_idx :: DrawList_PrimWriteIdx

draw_list_prim_vtx :: DrawList_PrimVtx

draw_data_new :: DrawData_new

draw_data_destroy :: DrawData_destroy

draw_data_clear :: DrawData_Clear

draw_data_add_draw_list :: DrawData_AddDrawList

draw_data_de_index_all_buffers :: DrawData_DeIndexAllBuffers

draw_data_scale_clip_rects :: DrawData_ScaleClipRects

font_config_new :: FontConfig_new

font_config_destroy :: FontConfig_destroy

font_glyph_ranges_builder_new :: FontGlyphRangesBuilder_new

font_glyph_ranges_builder_destroy :: FontGlyphRangesBuilder_destroy

font_glyph_ranges_builder_clear :: FontGlyphRangesBuilder_Clear

font_glyph_ranges_builder_get_bit :: FontGlyphRangesBuilder_GetBit

font_glyph_ranges_builder_set_bit :: FontGlyphRangesBuilder_SetBit

font_glyph_ranges_builder_add_char :: FontGlyphRangesBuilder_AddChar

font_glyph_ranges_builder_add_text :: proc(self: ^Font_Glyph_Ranges_Builder, text: string) {
	FontGlyphRangesBuilder_AddText(self, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))))
}

font_glyph_ranges_builder_add_ranges :: FontGlyphRangesBuilder_AddRanges

font_glyph_ranges_builder_build_ranges :: proc(self: ^Font_Glyph_Ranges_Builder) -> (out_ranges: Vector(u16)) {
	FontGlyphRangesBuilder_BuildRanges(self, &out_ranges)
	return
}

font_atlas_custom_rect_new :: FontAtlasCustomRect_new

font_atlas_custom_rect_destroy :: FontAtlasCustomRect_destroy

font_atlas_custom_rect_is_packed :: FontAtlasCustomRect_IsPacked

font_atlas_new :: FontAtlas_new

font_atlas_destroy :: FontAtlas_destroy

font_atlas_add_font :: FontAtlas_AddFont

font_atlas_add_font_default :: FontAtlas_AddFontDefault

font_atlas_add_font_from_file_ttf :: proc(self: ^Font_Atlas, filename: string, size_pixels: f32, font_cfg: ^Font_Config = nil, glyph_ranges: ^u16 = nil) -> ^Font {
	return FontAtlas_AddFontFromFileTTF(self, semisafe_string_to_cstring(filename), size_pixels, font_cfg, glyph_ranges)
}

font_atlas_add_font_from_memory_ttf :: FontAtlas_AddFontFromMemoryTTF

font_atlas_add_font_from_memory_compressed_ttf :: FontAtlas_AddFontFromMemoryCompressedTTF

font_atlas_add_font_from_memory_compressed_base85_ttf :: proc(self: ^Font_Atlas, compressed_font_data_base85: string, size_pixels: f32, font_cfg: ^Font_Config = nil, glyph_ranges: ^u16 = nil) -> ^Font {
	return FontAtlas_AddFontFromMemoryCompressedBase85TTF(self, semisafe_string_to_cstring(compressed_font_data_base85), size_pixels, font_cfg, glyph_ranges)
}

font_atlas_clear_input_data :: FontAtlas_ClearInputData

font_atlas_clear_tex_data :: FontAtlas_ClearTexData

font_atlas_clear_fonts :: FontAtlas_ClearFonts

font_atlas_clear :: FontAtlas_Clear

font_atlas_build :: FontAtlas_Build

font_atlas_get_tex_data_as_alpha8 :: proc(self: ^Font_Atlas) -> (out_pixels: ^u8, out_width: i32, out_height: i32, out_bytes_per_pixel: i32) {
	FontAtlas_GetTexDataAsAlpha8(self, &out_pixels, &out_width, &out_height, &out_bytes_per_pixel)
	return
}

font_atlas_get_tex_data_as_rgba32 :: proc(self: ^Font_Atlas) -> (out_pixels: ^u8, out_width: i32, out_height: i32, out_bytes_per_pixel: i32) {
	FontAtlas_GetTexDataAsRGBA32(self, &out_pixels, &out_width, &out_height, &out_bytes_per_pixel)
	return
}

font_atlas_is_built :: FontAtlas_IsBuilt

font_atlas_set_tex_id :: FontAtlas_SetTexID

font_atlas_get_glyph_ranges_default :: FontAtlas_GetGlyphRangesDefault

font_atlas_get_glyph_ranges_greek :: FontAtlas_GetGlyphRangesGreek

font_atlas_get_glyph_ranges_korean :: FontAtlas_GetGlyphRangesKorean

font_atlas_get_glyph_ranges_japanese :: FontAtlas_GetGlyphRangesJapanese

font_atlas_get_glyph_ranges_chinese_full :: FontAtlas_GetGlyphRangesChineseFull

font_atlas_get_glyph_ranges_chinese_simplified_common :: FontAtlas_GetGlyphRangesChineseSimplifiedCommon

font_atlas_get_glyph_ranges_cyrillic :: FontAtlas_GetGlyphRangesCyrillic

font_atlas_get_glyph_ranges_thai :: FontAtlas_GetGlyphRangesThai

font_atlas_get_glyph_ranges_vietnamese :: FontAtlas_GetGlyphRangesVietnamese

font_atlas_add_custom_rect_regular :: FontAtlas_AddCustomRectRegular

font_atlas_add_custom_rect_font_glyph :: FontAtlas_AddCustomRectFontGlyph

font_atlas_get_custom_rect_by_index :: FontAtlas_GetCustomRectByIndex

font_atlas_calc_custom_rect_uv :: proc(self: ^Font_Atlas, rect: ^Font_Atlas_Custom_Rect) -> (out_uv_min: [2]f32, out_uv_max: [2]f32) {
	FontAtlas_CalcCustomRectUV(self, rect, &out_uv_min, &out_uv_max)
	return
}

font_atlas_get_mouse_cursor_tex_data :: proc(self: ^Font_Atlas, cursor: Mouse_Cursor, out_uv_border: [2][2]f32, out_uv_fill: [2][2]f32) -> (orig_ret: bool, out_offset: [2]f32, out_size: [2]f32) {
	orig_ret = FontAtlas_GetMouseCursorTexData(self, cursor, &out_offset, &out_size, out_uv_border, out_uv_fill)
	return
}

font_new :: Font_new

font_destroy :: Font_destroy

font_find_glyph :: Font_FindGlyph

font_find_glyph_no_fallback :: Font_FindGlyphNoFallback

font_get_char_advance :: Font_GetCharAdvance

font_is_loaded :: Font_IsLoaded

font_get_debug_name :: Font_GetDebugName

font_calc_text_size_a :: proc(self: ^Font, size: f32, max_width: f32, wrap_width: f32, text: string, remaining: ^cstring = nil) -> (p_out: [2]f32) {
	Font_CalcTextSizeA(&p_out, self, size, max_width, wrap_width, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))), remaining)
	return
}

font_calc_word_wrap_position_a :: proc(self: ^Font, scale: f32, text: string, wrap_width: f32) -> cstring {
	return Font_CalcWordWrapPositionA(self, scale, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))), wrap_width)
}

font_render_char :: Font_RenderChar

font_render_text :: proc(self: ^Font, draw_list: ^Draw_List, size: f32, pos: [2]f32, col: u32, clip_rect: [4]f32, text: string, wrap_width: f32 = 0.0, cpu_fine_clip: bool = false) {
	Font_RenderText(self, draw_list, size, pos, col, clip_rect, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))), wrap_width, cpu_fine_clip)
}

font_build_lookup_table :: Font_BuildLookupTable

font_clear_output_data :: Font_ClearOutputData

font_grow_index :: Font_GrowIndex

font_add_glyph :: Font_AddGlyph

font_add_remap_char :: Font_AddRemapChar

font_set_glyph_visible :: Font_SetGlyphVisible

font_is_glyph_range_unused :: Font_IsGlyphRangeUnused

viewport_new :: Viewport_new

viewport_destroy :: Viewport_destroy

viewport_get_center :: proc(self: ^Viewport) -> (p_out: [2]f32) {
	Viewport_GetCenter(&p_out, self)
	return
}

viewport_get_work_center :: proc(self: ^Viewport) -> (p_out: [2]f32) {
	Viewport_GetWorkCenter(&p_out, self)
	return
}

platform_io_new :: PlatformIO_new

platform_io_destroy :: PlatformIO_destroy

platform_monitor_new :: PlatformMonitor_new

platform_monitor_destroy :: PlatformMonitor_destroy

platform_ime_data_new :: PlatformImeData_new

platform_ime_data_destroy :: PlatformImeData_destroy

get_key_index :: GetKeyIndex

im_bezier_cubic_calc :: proc(p1: [2]f32, p2: [2]f32, p3: [2]f32, p4: [2]f32, t: f32) -> (p_out: [2]f32) {
	ImBezierCubicCalc(&p_out, p1, p2, p3, p4, t)
	return
}

im_bezier_cubic_closest_point :: proc(p1: [2]f32, p2: [2]f32, p3: [2]f32, p4: [2]f32, p: [2]f32, num_segments: i32) -> (p_out: [2]f32) {
	ImBezierCubicClosestPoint(&p_out, p1, p2, p3, p4, p, num_segments)
	return
}

im_bezier_cubic_closest_point_casteljau :: proc(p1: [2]f32, p2: [2]f32, p3: [2]f32, p4: [2]f32, p: [2]f32, tess_tol: f32) -> (p_out: [2]f32) {
	ImBezierCubicClosestPointCasteljau(&p_out, p1, p2, p3, p4, p, tess_tol)
	return
}

im_bezier_quadratic_calc :: proc(p1: [2]f32, p2: [2]f32, p3: [2]f32, t: f32) -> (p_out: [2]f32) {
	ImBezierQuadraticCalc(&p_out, p1, p2, p3, t)
	return
}

rect_new :: proc {
	rect_new_nil,
	rect_new_vec2,
	rect_new_vec4,
	rect_new_float,
}
rect_new_nil :: Rect_Rect_Nil
rect_new_vec2 :: Rect_Rect_Vec2
rect_new_vec4 :: Rect_Rect_Vec4
rect_new_float :: Rect_Rect_Float

rect_destroy :: Rect_destroy

rect_get_center :: proc(self: ^Rect) -> (p_out: [2]f32) {
	Rect_GetCenter(&p_out, self)
	return
}

rect_get_size :: proc(self: ^Rect) -> (p_out: [2]f32) {
	Rect_GetSize(&p_out, self)
	return
}

rect_get_width :: Rect_GetWidth

rect_get_height :: Rect_GetHeight

rect_get_area :: Rect_GetArea

rect_get_tl :: proc(self: ^Rect) -> (p_out: [2]f32) {
	Rect_GetTL(&p_out, self)
	return
}

rect_get_tr :: proc(self: ^Rect) -> (p_out: [2]f32) {
	Rect_GetTR(&p_out, self)
	return
}

rect_get_bl :: proc(self: ^Rect) -> (p_out: [2]f32) {
	Rect_GetBL(&p_out, self)
	return
}

rect_get_br :: proc(self: ^Rect) -> (p_out: [2]f32) {
	Rect_GetBR(&p_out, self)
	return
}

rect_contains :: proc {
	rect_contains_vec2,
	rect_contains_rect,
}
rect_contains_vec2 :: Rect_Contains_Vec2
rect_contains_rect :: Rect_Contains_Rect

rect_overlaps :: Rect_Overlaps

rect_add :: proc {
	rect_add_vec2,
	rect_add_rect,
}
rect_add_vec2 :: Rect_Add_Vec2
rect_add_rect :: Rect_Add_Rect

rect_expand :: proc {
	rect_expand_float,
	rect_expand_vec2,
}
rect_expand_float :: Rect_Expand_Float
rect_expand_vec2 :: Rect_Expand_Vec2

rect_translate :: Rect_Translate

rect_translate_x :: Rect_TranslateX

rect_translate_y :: Rect_TranslateY

rect_clip_with :: Rect_ClipWith

rect_clip_with_full :: Rect_ClipWithFull

rect_floor :: Rect_Floor

rect_is_inverted :: Rect_IsInverted

rect_to_vec4 :: proc(self: ^Rect) -> (p_out: [4]f32) {
	Rect_ToVec4(&p_out, self)
	return
}

text_index_clear :: TextIndex_clear

text_index_size :: TextIndex_size

text_index_get_line_begin :: proc(self: ^Text_Index, base: string, n: i32) -> cstring {
	return TextIndex_get_line_begin(self, semisafe_string_to_cstring(base), n)
}

text_index_get_line_end :: proc(self: ^Text_Index, base: string, n: i32) -> cstring {
	return TextIndex_get_line_end(self, semisafe_string_to_cstring(base), n)
}

text_index_append :: proc(self: ^Text_Index, base: string, old_size: i32, new_size: i32) {
	TextIndex_append(self, semisafe_string_to_cstring(base), old_size, new_size)
}

draw_list_shared_data_new :: DrawListSharedData_new

draw_list_shared_data_destroy :: DrawListSharedData_destroy

draw_list_shared_data_set_circle_tessellation_max_error :: DrawListSharedData_SetCircleTessellationMaxError

draw_data_builder_new :: DrawDataBuilder_new

draw_data_builder_destroy :: DrawDataBuilder_destroy

data_var_info_get_var_ptr :: DataVarInfo_GetVarPtr

style_mod_new :: proc {
	style_mod_new_int,
	style_mod_new_float,
	style_mod_new_vec2,
}
style_mod_new_int :: StyleMod_StyleMod_Int
style_mod_new_float :: StyleMod_StyleMod_Float
style_mod_new_vec2 :: StyleMod_StyleMod_Vec2

style_mod_destroy :: StyleMod_destroy

combo_preview_data_new :: ComboPreviewData_new

combo_preview_data_destroy :: ComboPreviewData_destroy

menu_columns_new :: MenuColumns_new

menu_columns_destroy :: MenuColumns_destroy

menu_columns_update :: MenuColumns_Update

menu_columns_decl_columns :: MenuColumns_DeclColumns

menu_columns_calc_next_total_width :: MenuColumns_CalcNextTotalWidth

input_text_deactivated_state_new :: InputTextDeactivatedState_new

input_text_deactivated_state_destroy :: InputTextDeactivatedState_destroy

input_text_deactivated_state_clear_free_memory :: InputTextDeactivatedState_ClearFreeMemory

input_text_state_new :: InputTextState_new

input_text_state_destroy :: InputTextState_destroy

input_text_state_clear_text :: InputTextState_ClearText

input_text_state_clear_free_memory :: InputTextState_ClearFreeMemory

input_text_state_get_undo_avail_count :: InputTextState_GetUndoAvailCount

input_text_state_get_redo_avail_count :: InputTextState_GetRedoAvailCount

input_text_state_on_key_pressed :: InputTextState_OnKeyPressed

input_text_state_cursor_anim_reset :: InputTextState_CursorAnimReset

input_text_state_cursor_clamp :: InputTextState_CursorClamp

input_text_state_has_selection :: InputTextState_HasSelection

input_text_state_clear_selection :: InputTextState_ClearSelection

input_text_state_get_cursor_pos :: InputTextState_GetCursorPos

input_text_state_get_selection_start :: InputTextState_GetSelectionStart

input_text_state_get_selection_end :: InputTextState_GetSelectionEnd

input_text_state_select_all :: InputTextState_SelectAll

popup_data_new :: PopupData_new

popup_data_destroy :: PopupData_destroy

next_window_data_new :: NextWindowData_new

next_window_data_destroy :: NextWindowData_destroy

next_window_data_clear_flags :: NextWindowData_ClearFlags

next_item_data_new :: NextItemData_new

next_item_data_destroy :: NextItemData_destroy

next_item_data_clear_flags :: NextItemData_ClearFlags

last_item_data_new :: LastItemData_new

last_item_data_destroy :: LastItemData_destroy

stack_sizes_new :: StackSizes_new

stack_sizes_destroy :: StackSizes_destroy

stack_sizes_set_to_context_state :: StackSizes_SetToContextState

stack_sizes_compare_with_context_state :: StackSizes_CompareWithContextState

ptr_or_index_new :: proc {
	ptr_or_index_new_ptr,
	ptr_or_index_new_int,
}
ptr_or_index_new_ptr :: PtrOrIndex_PtrOrIndex_Ptr
ptr_or_index_new_int :: PtrOrIndex_PtrOrIndex_Int

ptr_or_index_destroy :: PtrOrIndex_destroy

input_event_new :: InputEvent_new

input_event_destroy :: InputEvent_destroy

key_routing_data_new :: KeyRoutingData_new

key_routing_data_destroy :: KeyRoutingData_destroy

key_routing_table_new :: KeyRoutingTable_new

key_routing_table_destroy :: KeyRoutingTable_destroy

key_routing_table_clear :: KeyRoutingTable_Clear

key_owner_data_new :: KeyOwnerData_new

key_owner_data_destroy :: KeyOwnerData_destroy

list_clipper_range_from_indices :: ListClipperRange_FromIndices

list_clipper_range_from_positions :: ListClipperRange_FromPositions

list_clipper_data_new :: ListClipperData_new

list_clipper_data_destroy :: ListClipperData_destroy

list_clipper_data_reset :: ListClipperData_Reset

nav_item_data_new :: NavItemData_new

nav_item_data_destroy :: NavItemData_destroy

nav_item_data_clear :: NavItemData_Clear

old_column_data_new :: OldColumnData_new

old_column_data_destroy :: OldColumnData_destroy

old_columns_new :: OldColumns_new

old_columns_destroy :: OldColumns_destroy

dock_node_new :: DockNode_new

dock_node_destroy :: DockNode_destroy

dock_node_is_root_node :: DockNode_IsRootNode

dock_node_is_dock_space :: DockNode_IsDockSpace

dock_node_is_floating_node :: DockNode_IsFloatingNode

dock_node_is_central_node :: DockNode_IsCentralNode

dock_node_is_hidden_tab_bar :: DockNode_IsHiddenTabBar

dock_node_is_no_tab_bar :: DockNode_IsNoTabBar

dock_node_is_split_node :: DockNode_IsSplitNode

dock_node_is_leaf_node :: DockNode_IsLeafNode

dock_node_is_empty :: DockNode_IsEmpty

dock_node_rect :: proc(self: ^Dock_Node) -> (p_out: Rect) {
	DockNode_Rect(&p_out, self)
	return
}

dock_node_set_local_flags :: DockNode_SetLocalFlags

dock_node_update_merged_flags :: DockNode_UpdateMergedFlags

dock_context_new :: DockContext_new

dock_context_destroy :: DockContext_destroy

viewport_p_new :: ViewportP_new

viewport_p_destroy :: ViewportP_destroy

viewport_p_clear_request_flags :: ViewportP_ClearRequestFlags

viewport_p_calc_work_rect_pos :: proc(self: ^Viewport_P, off_min: [2]f32) -> (p_out: [2]f32) {
	ViewportP_CalcWorkRectPos(&p_out, self, off_min)
	return
}

viewport_p_calc_work_rect_size :: proc(self: ^Viewport_P, off_min: [2]f32, off_max: [2]f32) -> (p_out: [2]f32) {
	ViewportP_CalcWorkRectSize(&p_out, self, off_min, off_max)
	return
}

viewport_p_update_work_rect :: ViewportP_UpdateWorkRect

viewport_p_get_main_rect :: proc(self: ^Viewport_P) -> (p_out: Rect) {
	ViewportP_GetMainRect(&p_out, self)
	return
}

viewport_p_get_work_rect :: proc(self: ^Viewport_P) -> (p_out: Rect) {
	ViewportP_GetWorkRect(&p_out, self)
	return
}

viewport_p_get_build_work_rect :: proc(self: ^Viewport_P) -> (p_out: Rect) {
	ViewportP_GetBuildWorkRect(&p_out, self)
	return
}

window_settings_new :: WindowSettings_new

window_settings_destroy :: WindowSettings_destroy

window_settings_get_name :: WindowSettings_GetName

settings_handler_new :: SettingsHandler_new

settings_handler_destroy :: SettingsHandler_destroy

stack_level_info_new :: StackLevelInfo_new

stack_level_info_destroy :: StackLevelInfo_destroy

stack_tool_new :: StackTool_new

stack_tool_destroy :: StackTool_destroy

context_hook_new :: ContextHook_new

context_hook_destroy :: ContextHook_destroy

context_new :: Context_new

context_destroy :: Context_destroy

window_new :: proc(context_: ^Context, name: string) -> ^Window {
	return Window_new(context_, semisafe_string_to_cstring(name))
}

window_destroy :: Window_destroy

window_get_id :: proc {
	window_get_id_str,
	window_get_id_ptr,
	window_get_id_int,
}
window_get_id_str :: proc(self: ^Window, str: string) -> ID {
	return Window_GetID_Str(self, raw_data(str), cast([^]u8) (uintptr(raw_data(str)) + uintptr(len(str))))
}
window_get_id_ptr :: Window_GetID_Ptr
window_get_id_int :: Window_GetID_Int

window_get_id_from_rectangle :: Window_GetIDFromRectangle

window_rect :: proc(self: ^Window) -> (p_out: Rect) {
	Window_Rect(&p_out, self)
	return
}

window_calc_font_size :: Window_CalcFontSize

window_title_bar_height :: Window_TitleBarHeight

window_title_bar_rect :: proc(self: ^Window) -> (p_out: Rect) {
	Window_TitleBarRect(&p_out, self)
	return
}

window_menu_bar_height :: Window_MenuBarHeight

window_menu_bar_rect :: proc(self: ^Window) -> (p_out: Rect) {
	Window_MenuBarRect(&p_out, self)
	return
}

tab_item_new :: TabItem_new

tab_item_destroy :: TabItem_destroy

tab_bar_new :: TabBar_new

tab_bar_destroy :: TabBar_destroy

table_column_new :: TableColumn_new

table_column_destroy :: TableColumn_destroy

table_instance_data_new :: TableInstanceData_new

table_instance_data_destroy :: TableInstanceData_destroy

table_new :: Table_new

table_destroy :: Table_destroy

table_temp_data_new :: TableTempData_new

table_temp_data_destroy :: TableTempData_destroy

table_column_settings_new :: TableColumnSettings_new

table_column_settings_destroy :: TableColumnSettings_destroy

table_settings_new :: TableSettings_new

table_settings_destroy :: TableSettings_destroy

table_settings_get_column_settings :: TableSettings_GetColumnSettings

get_current_window_read :: GetCurrentWindowRead

get_current_window :: GetCurrentWindow

find_window_by_id :: FindWindowByID

find_window_by_name :: proc(name: string) -> ^Window {
	return FindWindowByName(semisafe_string_to_cstring(name))
}

update_window_parent_and_root_links :: UpdateWindowParentAndRootLinks

calc_window_next_auto_fit_size :: proc(window: ^Window) -> (p_out: [2]f32) {
	CalcWindowNextAutoFitSize(&p_out, window)
	return
}

is_window_child_of :: IsWindowChildOf

is_window_within_begin_stack_of :: IsWindowWithinBeginStackOf

is_window_above :: IsWindowAbove

is_window_nav_focusable :: IsWindowNavFocusable

set_window_hit_test_hole :: SetWindowHitTestHole

set_window_hiddend_and_skip_items_for_current_frame :: SetWindowHiddendAndSkipItemsForCurrentFrame

window_rect_abs_to_rel :: proc(window: ^Window, r: Rect) -> (p_out: Rect) {
	WindowRectAbsToRel(&p_out, window, r)
	return
}

window_rect_rel_to_abs :: proc(window: ^Window, r: Rect) -> (p_out: Rect) {
	WindowRectRelToAbs(&p_out, window, r)
	return
}

window_pos_rel_to_abs :: proc(window: ^Window, p: [2]f32) -> (p_out: [2]f32) {
	WindowPosRelToAbs(&p_out, window, p)
	return
}

focus_window :: FocusWindow

focus_top_most_window_under_one :: FocusTopMostWindowUnderOne

bring_window_to_focus_front :: BringWindowToFocusFront

bring_window_to_display_front :: BringWindowToDisplayFront

bring_window_to_display_back :: BringWindowToDisplayBack

bring_window_to_display_behind :: BringWindowToDisplayBehind

find_window_display_index :: FindWindowDisplayIndex

find_bottom_most_visible_window_within_begin_stack :: FindBottomMostVisibleWindowWithinBeginStack

set_current_font :: SetCurrentFont

get_default_font :: GetDefaultFont

add_draw_list_to_draw_data_ex :: proc(draw_data: ^Draw_Data, draw_list: ^Draw_List) -> (out_list: Vector(^Draw_List)) {
	AddDrawListToDrawDataEx(draw_data, &out_list, draw_list)
	return
}

initialize :: Initialize

shutdown :: Shutdown

update_input_events :: UpdateInputEvents

update_hovered_window_and_capture_flags :: UpdateHoveredWindowAndCaptureFlags

start_mouse_moving_window :: StartMouseMovingWindow

start_mouse_moving_window_or_node :: StartMouseMovingWindowOrNode

update_mouse_moving_window_new_frame :: UpdateMouseMovingWindowNewFrame

update_mouse_moving_window_end_frame :: UpdateMouseMovingWindowEndFrame

add_context_hook :: AddContextHook

remove_context_hook :: RemoveContextHook

call_context_hooks :: CallContextHooks

translate_windows_in_viewport :: TranslateWindowsInViewport

scale_windows_in_viewport :: ScaleWindowsInViewport

destroy_platform_window :: DestroyPlatformWindow

set_window_viewport :: SetWindowViewport

set_current_viewport :: SetCurrentViewport

get_viewport_platform_monitor :: GetViewportPlatformMonitor

find_hovered_viewport_from_platform_window_stack :: FindHoveredViewportFromPlatformWindowStack

mark_ini_settings_dirty :: proc {
	mark_ini_settings_dirty_nil,
	mark_ini_settings_dirty_window_ptr,
}
mark_ini_settings_dirty_nil :: MarkIniSettingsDirty_Nil
mark_ini_settings_dirty_window_ptr :: MarkIniSettingsDirty_WindowPtr

clear_ini_settings :: ClearIniSettings

add_settings_handler :: AddSettingsHandler

remove_settings_handler :: proc(type_name: string) {
	RemoveSettingsHandler(semisafe_string_to_cstring(type_name))
}

find_settings_handler :: proc(type_name: string) -> ^Settings_Handler {
	return FindSettingsHandler(semisafe_string_to_cstring(type_name))
}

create_new_window_settings :: proc(name: string) -> ^Window_Settings {
	return CreateNewWindowSettings(semisafe_string_to_cstring(name))
}

find_window_settings_by_id :: FindWindowSettingsByID

find_window_settings_by_window :: FindWindowSettingsByWindow

clear_window_settings :: proc(name: string) {
	ClearWindowSettings(semisafe_string_to_cstring(name))
}

localize_register_entries :: LocalizeRegisterEntries

localize_get_msg :: LocalizeGetMsg

scroll_to_item :: ScrollToItem

scroll_to_rect :: ScrollToRect

scroll_to_rect_ex :: proc(window: ^Window, rect: Rect, flags: Scroll_Flags = {  }) -> (p_out: [2]f32) {
	ScrollToRectEx(&p_out, window, rect, flags)
	return
}

scroll_to_bring_rect_into_view :: ScrollToBringRectIntoView

get_item_status_flags :: GetItemStatusFlags

get_item_flags :: GetItemFlags

get_active_id :: GetActiveID

get_focus_id :: GetFocusID

set_active_id :: SetActiveID

set_focus_id :: SetFocusID

clear_active_id :: ClearActiveID

get_hovered_id :: GetHoveredID

set_hovered_id :: SetHoveredID

keep_alive_id :: KeepAliveID

mark_item_edited :: MarkItemEdited

push_override_id :: PushOverrideID

get_id_with_seed :: proc {
	get_id_with_seed_str,
	get_id_with_seed_int,
}
get_id_with_seed_str :: proc(str_id: string, seed: ID) -> ID {
	return GetIDWithSeed_Str(raw_data(str_id), cast([^]u8) (uintptr(raw_data(str_id)) + uintptr(len(str_id))), seed)
}
get_id_with_seed_int :: GetIDWithSeed_Int

item_size :: proc {
	item_size_vec2,
	item_size_rect,
}
item_size_vec2 :: ItemSize_Vec2
item_size_rect :: ItemSize_Rect

item_add :: ItemAdd

item_hoverable :: ItemHoverable

is_window_content_hoverable :: IsWindowContentHoverable

is_clipped_ex :: IsClippedEx

set_last_item_data :: SetLastItemData

calc_item_size :: proc(size: [2]f32, default_w: f32, default_h: f32) -> (p_out: [2]f32) {
	CalcItemSize(&p_out, size, default_w, default_h)
	return
}

calc_wrap_width_for_pos :: CalcWrapWidthForPos

push_multi_items_widths :: PushMultiItemsWidths

is_item_toggled_selection :: IsItemToggledSelection

get_content_region_max_abs :: proc() -> (p_out: [2]f32) {
	GetContentRegionMaxAbs(&p_out)
	return
}

shrink_widths :: ShrinkWidths

push_item_flag :: PushItemFlag

pop_item_flag :: PopItemFlag

get_style_var_info :: GetStyleVarInfo

log_begin :: LogBegin

log_to_buffer :: LogToBuffer

log_rendered_text :: proc(ref_pos: ^[2]f32, text: string) {
	LogRenderedText(ref_pos, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))))
}

log_set_next_text_decoration :: proc(prefix: string, suffix: string) {
	LogSetNextTextDecoration(semisafe_string_to_cstring(prefix), semisafe_string_to_cstring(suffix))
}

begin_child_ex :: proc(name: string, id: ID, size_arg: [2]f32, border: bool, flags: Window_Flags) -> bool {
	return BeginChildEx(semisafe_string_to_cstring(name), id, size_arg, border, flags)
}

open_popup_ex :: OpenPopupEx

close_popup_to_level :: ClosePopupToLevel

close_popups_over_window :: ClosePopupsOverWindow

close_popups_except_modals :: ClosePopupsExceptModals

begin_popup_ex :: BeginPopupEx

begin_tooltip_ex :: BeginTooltipEx

get_popup_allowed_extent_rect :: proc(window: ^Window) -> (p_out: Rect) {
	GetPopupAllowedExtentRect(&p_out, window)
	return
}

get_top_most_popup_modal :: GetTopMostPopupModal

get_top_most_and_visible_popup_modal :: GetTopMostAndVisiblePopupModal

find_blocking_modal :: FindBlockingModal

find_best_window_pos_for_popup :: proc(window: ^Window) -> (p_out: [2]f32) {
	FindBestWindowPosForPopup(&p_out, window)
	return
}

find_best_window_pos_for_popup_ex :: proc(ref_pos: [2]f32, size: [2]f32, last_dir: ^Dir, r_outer: Rect, r_avoid: Rect, policy: Popup_Position_Policy) -> (p_out: [2]f32) {
	FindBestWindowPosForPopupEx(&p_out, ref_pos, size, last_dir, r_outer, r_avoid, policy)
	return
}

begin_viewport_side_bar :: proc(name: string, viewport: ^Viewport, dir: Dir, size: f32, window_flags: Window_Flags) -> bool {
	return BeginViewportSideBar(semisafe_string_to_cstring(name), viewport, dir, size, window_flags)
}

begin_menu_ex :: proc(label: string, icon: string, enabled: bool = true) -> bool {
	return BeginMenuEx(semisafe_string_to_cstring(label), semisafe_string_to_cstring(icon), enabled)
}

menu_item_ex :: proc(label: string, icon: string, shortcut: string = "", selected: bool = false, enabled: bool = true) -> bool {
	return MenuItemEx(semisafe_string_to_cstring(label), semisafe_string_to_cstring(icon), semisafe_string_to_cstring(shortcut), selected, enabled)
}

begin_combo_popup :: BeginComboPopup

begin_combo_preview :: BeginComboPreview

end_combo_preview :: EndComboPreview

nav_init_window :: NavInitWindow

nav_init_request_apply_result :: NavInitRequestApplyResult

nav_move_request_but_no_result_yet :: NavMoveRequestButNoResultYet

nav_move_request_submit :: NavMoveRequestSubmit

nav_move_request_forward :: NavMoveRequestForward

nav_move_request_resolve_with_last_item :: NavMoveRequestResolveWithLastItem

nav_move_request_cancel :: NavMoveRequestCancel

nav_move_request_apply_result :: NavMoveRequestApplyResult

nav_move_request_try_wrapping :: NavMoveRequestTryWrapping

nav_clear_preferred_pos_for_axis :: NavClearPreferredPosForAxis

nav_update_current_window_is_scroll_pushable_x :: NavUpdateCurrentWindowIsScrollPushableX

set_nav_window :: SetNavWindow

set_nav_id :: SetNavID

focus_item :: FocusItem

activate_item_by_id :: ActivateItemByID

is_named_key :: IsNamedKey

is_named_key_or_mod_key :: IsNamedKeyOrModKey

is_legacy_key :: IsLegacyKey

is_keyboard_key :: IsKeyboardKey

is_gamepad_key :: IsGamepadKey

is_mouse_key :: IsMouseKey

is_alias_key :: IsAliasKey

convert_shortcut_mod :: ConvertShortcutMod

convert_single_mod_flag_to_key :: ConvertSingleModFlagToKey

get_key_data :: proc {
	get_key_data_context_ptr,
	get_key_data_key,
}
get_key_data_context_ptr :: GetKeyData_ContextPtr
get_key_data_key :: GetKeyData_Key

get_key_chord_name :: proc(key_chord: Key_Chord, out_buf_size: i32) -> (out_buf: i8) {
	GetKeyChordName(key_chord, &out_buf, out_buf_size)
	return
}

mouse_button_to_key :: MouseButtonToKey

is_mouse_drag_past_threshold :: IsMouseDragPastThreshold

get_key_magnitude2d :: proc(key_left: Key, key_right: Key, key_up: Key, key_down: Key) -> (p_out: [2]f32) {
	GetKeyMagnitude2d(&p_out, key_left, key_right, key_up, key_down)
	return
}

get_nav_tweak_pressed_amount :: GetNavTweakPressedAmount

calc_typematic_repeat_amount :: CalcTypematicRepeatAmount

get_typematic_repeat_rate :: GetTypematicRepeatRate

set_active_id_using_all_keyboard_keys :: SetActiveIdUsingAllKeyboardKeys

is_active_id_using_nav_dir :: IsActiveIdUsingNavDir

get_key_owner :: GetKeyOwner

set_key_owner :: SetKeyOwner

set_key_owners_for_key_chord :: SetKeyOwnersForKeyChord

set_item_key_owner :: SetItemKeyOwner

test_key_owner :: TestKeyOwner

get_key_owner_data :: GetKeyOwnerData

shortcut :: Shortcut

set_shortcut_routing :: SetShortcutRouting

test_shortcut_routing :: TestShortcutRouting

get_shortcut_routing_data :: GetShortcutRoutingData

dock_context_initialize :: DockContextInitialize

dock_context_shutdown :: DockContextShutdown

dock_context_clear_nodes :: DockContextClearNodes

dock_context_rebuild_nodes :: DockContextRebuildNodes

dock_context_new_frame_update_undocking :: DockContextNewFrameUpdateUndocking

dock_context_new_frame_update_docking :: DockContextNewFrameUpdateDocking

dock_context_end_frame :: DockContextEndFrame

dock_context_gen_node_id :: DockContextGenNodeID

dock_context_queue_dock :: DockContextQueueDock

dock_context_queue_undock_window :: DockContextQueueUndockWindow

dock_context_queue_undock_node :: DockContextQueueUndockNode

dock_context_process_undock_window :: DockContextProcessUndockWindow

dock_context_process_undock_node :: DockContextProcessUndockNode

dock_context_calc_drop_pos_for_docking :: proc(target: ^Window, target_node: ^Dock_Node, payload_window: ^Window, payload_node: ^Dock_Node, split_dir: Dir, split_outer: bool) -> (orig_ret: bool, out_pos: [2]f32) {
	orig_ret = DockContextCalcDropPosForDocking(target, target_node, payload_window, payload_node, split_dir, split_outer, &out_pos)
	return
}

dock_context_find_node_by_id :: DockContextFindNodeByID

dock_node_window_menu_handler_default :: DockNodeWindowMenuHandler_Default

dock_node_begin_amend_tab_bar :: DockNodeBeginAmendTabBar

dock_node_end_amend_tab_bar :: DockNodeEndAmendTabBar

dock_node_get_root_node :: DockNodeGetRootNode

dock_node_is_in_hierarchy_of :: DockNodeIsInHierarchyOf

dock_node_get_depth :: DockNodeGetDepth

dock_node_get_window_menu_button_id :: DockNodeGetWindowMenuButtonId

get_window_dock_node :: GetWindowDockNode

get_window_always_want_own_tab_bar :: GetWindowAlwaysWantOwnTabBar

begin_docked :: BeginDocked

begin_dockable_drag_drop_source :: BeginDockableDragDropSource

begin_dockable_drag_drop_target :: BeginDockableDragDropTarget

set_window_dock :: SetWindowDock

dock_builder_dock_window :: proc(window_name: string, node_id: ID) {
	DockBuilderDockWindow(semisafe_string_to_cstring(window_name), node_id)
}

dock_builder_get_node :: DockBuilderGetNode

dock_builder_get_central_node :: DockBuilderGetCentralNode

dock_builder_add_node :: DockBuilderAddNode

dock_builder_remove_node :: DockBuilderRemoveNode

dock_builder_remove_node_docked_windows :: DockBuilderRemoveNodeDockedWindows

dock_builder_remove_node_child_nodes :: DockBuilderRemoveNodeChildNodes

dock_builder_set_node_pos :: DockBuilderSetNodePos

dock_builder_set_node_size :: DockBuilderSetNodeSize

dock_builder_split_node :: proc(node_id: ID, split_dir: Dir, size_ratio_for_node_at_dir: f32) -> (orig_ret: ID, out_id_at_dir: ID, out_id_at_opposite_dir: ID) {
	orig_ret = DockBuilderSplitNode(node_id, split_dir, size_ratio_for_node_at_dir, &out_id_at_dir, &out_id_at_opposite_dir)
	return
}

dock_builder_copy_dock_space :: DockBuilderCopyDockSpace

dock_builder_copy_node :: proc(src_node_id: ID, dst_node_id: ID) -> (out_node_remap_pairs: Vector(ID)) {
	DockBuilderCopyNode(src_node_id, dst_node_id, &out_node_remap_pairs)
	return
}

dock_builder_copy_window_settings :: proc(src_name: string, dst_name: string) {
	DockBuilderCopyWindowSettings(semisafe_string_to_cstring(src_name), semisafe_string_to_cstring(dst_name))
}

dock_builder_finish :: DockBuilderFinish

push_focus_scope :: PushFocusScope

pop_focus_scope :: PopFocusScope

get_current_focus_scope :: GetCurrentFocusScope

is_drag_drop_active :: IsDragDropActive

begin_drag_drop_target_custom :: BeginDragDropTargetCustom

clear_drag_drop :: ClearDragDrop

is_drag_drop_payload_being_accepted :: IsDragDropPayloadBeingAccepted

render_drag_drop_target_rect :: RenderDragDropTargetRect

set_window_clip_rect_before_set_channel :: SetWindowClipRectBeforeSetChannel

begin_columns :: proc(str_id: string, count: i32, flags: Old_Column_Flags = {  }) {
	BeginColumns(semisafe_string_to_cstring(str_id), count, flags)
}

end_columns :: EndColumns

push_column_clip_rect :: PushColumnClipRect

push_columns_background :: PushColumnsBackground

pop_columns_background :: PopColumnsBackground

get_columns_id :: proc(str_id: string, count: i32) -> ID {
	return GetColumnsID(semisafe_string_to_cstring(str_id), count)
}

find_or_create_columns :: FindOrCreateColumns

get_column_offset_from_norm :: GetColumnOffsetFromNorm

get_column_norm_from_offset :: GetColumnNormFromOffset

table_open_context_menu :: TableOpenContextMenu

table_set_column_width :: TableSetColumnWidth

table_set_column_sort_direction :: TableSetColumnSortDirection

table_get_hovered_column :: TableGetHoveredColumn

table_get_hovered_row :: TableGetHoveredRow

table_get_header_row_height :: TableGetHeaderRowHeight

table_push_background_channel :: TablePushBackgroundChannel

table_pop_background_channel :: TablePopBackgroundChannel

get_current_table :: GetCurrentTable

table_find_by_id :: TableFindByID

begin_table_ex :: proc(name: string, id: ID, columns_count: i32, flags: Table_Flags = {  }, outer_size: [2]f32 = {0, 0}, inner_width: f32 = 0.0) -> bool {
	return BeginTableEx(semisafe_string_to_cstring(name), id, columns_count, flags, outer_size, inner_width)
}

table_begin_init_memory :: TableBeginInitMemory

table_begin_apply_requests :: TableBeginApplyRequests

table_setup_draw_channels :: TableSetupDrawChannels

table_update_layout :: TableUpdateLayout

table_update_borders :: TableUpdateBorders

table_update_columns_weight_from_width :: TableUpdateColumnsWeightFromWidth

table_draw_borders :: TableDrawBorders

table_draw_context_menu :: TableDrawContextMenu

table_begin_context_menu_popup :: TableBeginContextMenuPopup

table_merge_draw_channels :: TableMergeDrawChannels

table_get_instance_data :: TableGetInstanceData

table_get_instance_id :: TableGetInstanceID

table_sort_specs_sanitize :: TableSortSpecsSanitize

table_sort_specs_build :: TableSortSpecsBuild

table_get_column_next_sort_direction :: TableGetColumnNextSortDirection

table_fix_column_sort_direction :: TableFixColumnSortDirection

table_get_column_width_auto :: TableGetColumnWidthAuto

table_begin_row :: TableBeginRow

table_end_row :: TableEndRow

table_begin_cell :: TableBeginCell

table_end_cell :: TableEndCell

table_get_cell_bg_rect :: proc(table: ^Table, column_n: i32) -> (p_out: Rect) {
	TableGetCellBgRect(&p_out, table, column_n)
	return
}

table_get_column_resize_id :: TableGetColumnResizeID

table_get_max_column_width :: TableGetMaxColumnWidth

table_set_column_width_auto_single :: TableSetColumnWidthAutoSingle

table_set_column_width_auto_all :: TableSetColumnWidthAutoAll

table_remove :: TableRemove

table_gc_compact_transient_buffers :: proc {
	table_gc_compact_transient_buffers_table_ptr,
	table_gc_compact_transient_buffers_table_temp_data_ptr,
}
table_gc_compact_transient_buffers_table_ptr :: TableGcCompactTransientBuffers_TablePtr
table_gc_compact_transient_buffers_table_temp_data_ptr :: TableGcCompactTransientBuffers_TableTempDataPtr

table_gc_compact_settings :: TableGcCompactSettings

table_load_settings :: TableLoadSettings

table_save_settings :: TableSaveSettings

table_reset_settings :: TableResetSettings

table_get_bound_settings :: TableGetBoundSettings

table_settings_add_settings_handler :: TableSettingsAddSettingsHandler

table_settings_create :: TableSettingsCreate

table_settings_find_by_id :: TableSettingsFindByID

get_current_tab_bar :: GetCurrentTabBar

begin_tab_bar_ex :: BeginTabBarEx

tab_bar_find_tab_by_id :: TabBarFindTabByID

tab_bar_find_tab_by_order :: TabBarFindTabByOrder

tab_bar_find_most_recently_selected_tab_for_active_window :: TabBarFindMostRecentlySelectedTabForActiveWindow

tab_bar_get_current_tab :: TabBarGetCurrentTab

tab_bar_get_tab_order :: TabBarGetTabOrder

tab_bar_get_tab_name :: TabBarGetTabName

tab_bar_add_tab :: TabBarAddTab

tab_bar_remove_tab :: TabBarRemoveTab

tab_bar_close_tab :: TabBarCloseTab

tab_bar_queue_focus :: TabBarQueueFocus

tab_bar_queue_reorder :: TabBarQueueReorder

tab_bar_queue_reorder_from_mouse_pos :: TabBarQueueReorderFromMousePos

tab_bar_process_reorder :: TabBarProcessReorder

tab_item_ex :: proc(tab_bar: ^Tab_Bar, label: string, p_open: ^bool, flags: Tab_Item_Flags, docked_window: ^Window) -> bool {
	return TabItemEx(tab_bar, semisafe_string_to_cstring(label), p_open, flags, docked_window)
}

tab_item_calc_size :: proc {
	tab_item_calc_size_str,
	tab_item_calc_size_window_ptr,
}
tab_item_calc_size_str :: proc(label: string, has_close_button_or_unsaved_marker: bool) -> (p_out: [2]f32) {
	TabItemCalcSize_Str(&p_out, semisafe_string_to_cstring(label), has_close_button_or_unsaved_marker)
	return
}
tab_item_calc_size_window_ptr :: proc(window: ^Window) -> (p_out: [2]f32) {
	TabItemCalcSize_WindowPtr(&p_out, window)
	return
}

tab_item_background :: TabItemBackground

tab_item_label_and_close_button :: proc(draw_list: ^Draw_List, bb: Rect, flags: Tab_Item_Flags, frame_padding: [2]f32, label: string, tab_id: ID, close_button_id: ID, is_contents_visible: bool) -> (out_just_closed: bool, out_text_clipped: bool) {
	TabItemLabelAndCloseButton(draw_list, bb, flags, frame_padding, semisafe_string_to_cstring(label), tab_id, close_button_id, is_contents_visible, &out_just_closed, &out_text_clipped)
	return
}

render_text :: proc(pos: [2]f32, text: string, hide_text_after_hash: bool = true) {
	RenderText(pos, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))), hide_text_after_hash)
}

render_text_wrapped :: proc(pos: [2]f32, text: string, wrap_width: f32) {
	RenderTextWrapped(pos, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))), wrap_width)
}

render_text_clipped :: proc(pos_min: [2]f32, pos_max: [2]f32, text: string, text_size_if_known: ^[2]f32, align: [2]f32 = {0, 0}, clip_rect: ^Rect = nil) {
	RenderTextClipped(pos_min, pos_max, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))), text_size_if_known, align, clip_rect)
}

render_text_clipped_ex :: proc(draw_list: ^Draw_List, pos_min: [2]f32, pos_max: [2]f32, text: string, text_size_if_known: ^[2]f32, align: [2]f32 = {0, 0}, clip_rect: ^Rect = nil) {
	RenderTextClippedEx(draw_list, pos_min, pos_max, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))), text_size_if_known, align, clip_rect)
}

render_text_ellipsis :: proc(draw_list: ^Draw_List, pos_min: [2]f32, pos_max: [2]f32, clip_max_x: f32, ellipsis_max_x: f32, text: string, text_size_if_known: ^[2]f32) {
	RenderTextEllipsis(draw_list, pos_min, pos_max, clip_max_x, ellipsis_max_x, raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))), text_size_if_known)
}

render_frame :: RenderFrame

render_frame_border :: RenderFrameBorder

render_color_rect_with_alpha_checkerboard :: RenderColorRectWithAlphaCheckerboard

render_nav_highlight :: RenderNavHighlight

find_rendered_text_end :: proc(text: string) -> cstring {
	return FindRenderedTextEnd(raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))))
}

render_mouse_cursor :: RenderMouseCursor

render_arrow :: RenderArrow

render_bullet :: RenderBullet

render_check_mark :: RenderCheckMark

render_arrow_pointing_at :: RenderArrowPointingAt

render_arrow_dock_menu :: RenderArrowDockMenu

render_rect_filled_range_h :: RenderRectFilledRangeH

render_rect_filled_with_hole :: RenderRectFilledWithHole

calc_rounding_flags_for_rect_in_rect :: CalcRoundingFlagsForRectInRect

text_ex :: proc(text: string, flags: Text_Flags = {  }) {
	TextEx(raw_data(text), cast([^]u8) (uintptr(raw_data(text)) + uintptr(len(text))), flags)
}

button_ex :: proc(label: string, size_arg: [2]f32 = {0, 0}, flags: Button_Flags = {  }) -> bool {
	return ButtonEx(semisafe_string_to_cstring(label), size_arg, flags)
}

arrow_button_ex :: proc(str_id: string, dir: Dir, size_arg: [2]f32, flags: Button_Flags = {  }) -> bool {
	return ArrowButtonEx(semisafe_string_to_cstring(str_id), dir, size_arg, flags)
}

image_button_ex :: ImageButtonEx

separator_ex :: SeparatorEx

separator_text_ex :: proc(id: ID, label: string, extra_width: f32) {
	SeparatorTextEx(id, raw_data(label), cast([^]u8) (uintptr(raw_data(label)) + uintptr(len(label))), extra_width)
}

close_button :: CloseButton

collapse_button :: CollapseButton

scrollbar :: Scrollbar

scrollbar_ex :: ScrollbarEx

get_window_scrollbar_rect :: proc(window: ^Window, axis: Axis) -> (p_out: Rect) {
	GetWindowScrollbarRect(&p_out, window, axis)
	return
}

get_window_scrollbar_id :: GetWindowScrollbarID

get_window_resize_corner_id :: GetWindowResizeCornerID

get_window_resize_border_id :: GetWindowResizeBorderID

button_behavior :: proc(bb: Rect, id: ID, flags: Button_Flags = {  }) -> (orig_ret: bool, out_hovered: bool, out_held: bool) {
	orig_ret = ButtonBehavior(bb, id, &out_hovered, &out_held, flags)
	return
}

drag_behavior :: proc(id: ID, data_type: Data_Type, p_v: rawptr, v_speed: f32, p_min: rawptr, p_max: rawptr, format: string, flags: Slider_Flags) -> bool {
	return DragBehavior(id, data_type, p_v, v_speed, p_min, p_max, semisafe_string_to_cstring(format), flags)
}

slider_behavior :: proc(bb: Rect, id: ID, data_type: Data_Type, p_v: rawptr, p_min: rawptr, p_max: rawptr, format: string, flags: Slider_Flags) -> (orig_ret: bool, out_grab_bb: Rect) {
	orig_ret = SliderBehavior(bb, id, data_type, p_v, p_min, p_max, semisafe_string_to_cstring(format), flags, &out_grab_bb)
	return
}

splitter_behavior :: SplitterBehavior

tree_node_behavior :: proc(id: ID, flags: Tree_Node_Flags, label: string) -> bool {
	return TreeNodeBehavior(id, flags, raw_data(label), cast([^]u8) (uintptr(raw_data(label)) + uintptr(len(label))))
}

tree_push_override_id :: TreePushOverrideID

tree_node_set_open :: TreeNodeSetOpen

tree_node_update_next_open :: TreeNodeUpdateNextOpen

data_type_get_info :: DataTypeGetInfo

data_type_format_string :: proc(buf: []i8, data_type: Data_Type, p_data: rawptr, format: string) -> i32 {
	return DataTypeFormatString(raw_data(buf), cast(i32)len(buf), data_type, p_data, semisafe_string_to_cstring(format))
}

data_type_apply_op :: DataTypeApplyOp

data_type_apply_from_text :: proc(buf: string, data_type: Data_Type, p_data: rawptr, format: string) -> bool {
	return DataTypeApplyFromText(semisafe_string_to_cstring(buf), data_type, p_data, semisafe_string_to_cstring(format))
}

data_type_compare :: DataTypeCompare

data_type_clamp :: DataTypeClamp

input_text_ex :: proc(label: string, hint: string, buf: []i8, size_arg: [2]f32, flags: Input_Text_Flags, callback: Input_Text_Callback = nil, user_data: rawptr = nil) -> bool {
	return InputTextEx(semisafe_string_to_cstring(label), semisafe_string_to_cstring(hint), raw_data(buf), cast(i32)len(buf), size_arg, flags, callback, user_data)
}

input_text_deactivate_hook :: InputTextDeactivateHook

temp_input_text :: proc(bb: Rect, id: ID, label: string, buf: []i8, flags: Input_Text_Flags) -> bool {
	return TempInputText(bb, id, semisafe_string_to_cstring(label), raw_data(buf), cast(i32)len(buf), flags)
}

temp_input_scalar :: proc(bb: Rect, id: ID, label: string, data_type: Data_Type, p_data: rawptr, format: string, p_clamp_min: rawptr = nil, p_clamp_max: rawptr = nil) -> bool {
	return TempInputScalar(bb, id, semisafe_string_to_cstring(label), data_type, p_data, semisafe_string_to_cstring(format), p_clamp_min, p_clamp_max)
}

temp_input_is_active :: TempInputIsActive

get_input_text_state :: GetInputTextState

color_tooltip :: proc(text: string, col: ^f32, flags: Color_Edit_Flags) {
	ColorTooltip(semisafe_string_to_cstring(text), col, flags)
}

color_edit_options_popup :: ColorEditOptionsPopup

color_picker_options_popup :: ColorPickerOptionsPopup

plot_ex :: proc(plot_type: Plot_Type, label: string, values_getter: #type proc "c"(data: rawptr, idx: i32) -> f32, data: rawptr, values_count: i32, values_offset: i32, overlay_text: string, scale_min: f32, scale_max: f32, size_arg: [2]f32) -> i32 {
	return PlotEx(plot_type, semisafe_string_to_cstring(label), values_getter, data, values_count, values_offset, semisafe_string_to_cstring(overlay_text), scale_min, scale_max, size_arg)
}

shade_verts_linear_color_gradient_keep_alpha :: ShadeVertsLinearColorGradientKeepAlpha

shade_verts_linear_uv :: ShadeVertsLinearUV

gc_compact_transient_misc_buffers :: GcCompactTransientMiscBuffers

gc_compact_transient_window_buffers :: GcCompactTransientWindowBuffers

gc_awake_transient_window_buffers :: GcAwakeTransientWindowBuffers

debug_log :: proc(fmt_: string, _args_: ..any) {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	DebugLog("%s", cstring(raw_data(_fmt_sb.buf)))
}

error_check_end_frame_recover :: ErrorCheckEndFrameRecover

error_check_end_window_recover :: ErrorCheckEndWindowRecover

error_check_using_set_cursor_pos_to_extend_parent_boundaries :: ErrorCheckUsingSetCursorPosToExtendParentBoundaries

debug_locate_item :: DebugLocateItem

debug_locate_item_on_hover :: DebugLocateItemOnHover

debug_locate_item_resolve_with_last_item :: DebugLocateItemResolveWithLastItem

debug_draw_item_rect :: DebugDrawItemRect

debug_start_item_picker :: DebugStartItemPicker

show_font_atlas :: ShowFontAtlas

debug_hook_id_info :: DebugHookIdInfo

debug_node_columns :: DebugNodeColumns

debug_node_dock_node :: proc(node: ^Dock_Node, label: string) {
	DebugNodeDockNode(node, semisafe_string_to_cstring(label))
}

debug_node_draw_list :: proc(window: ^Window, viewport: ^Viewport_P, draw_list: ^Draw_List, label: string) {
	DebugNodeDrawList(window, viewport, draw_list, semisafe_string_to_cstring(label))
}

debug_node_draw_cmd_show_mesh_and_bounding_box :: proc(draw_list: ^Draw_List, draw_cmd: ^Draw_Cmd, show_mesh: bool, show_aabb: bool) -> (out_draw_list: Draw_List) {
	DebugNodeDrawCmdShowMeshAndBoundingBox(&out_draw_list, draw_list, draw_cmd, show_mesh, show_aabb)
	return
}

debug_node_font :: DebugNodeFont

debug_node_font_glyph :: DebugNodeFontGlyph

debug_node_storage :: proc(storage: ^Storage, label: string) {
	DebugNodeStorage(storage, semisafe_string_to_cstring(label))
}

debug_node_tab_bar :: proc(tab_bar: ^Tab_Bar, label: string) {
	DebugNodeTabBar(tab_bar, semisafe_string_to_cstring(label))
}

debug_node_table :: DebugNodeTable

debug_node_table_settings :: DebugNodeTableSettings

debug_node_input_text_state :: DebugNodeInputTextState

debug_node_window :: proc(window: ^Window, label: string) {
	DebugNodeWindow(window, semisafe_string_to_cstring(label))
}

debug_node_window_settings :: DebugNodeWindowSettings

debug_node_windows_list :: proc(windows: ^Vector(^Window), label: string) {
	DebugNodeWindowsList(windows, semisafe_string_to_cstring(label))
}

debug_node_windows_list_by_begin_stack_parent :: proc(windows: []^Window, parent_in_begin_stack: ^Window) {
	DebugNodeWindowsListByBeginStackParent(raw_data(windows), cast(i32)len(windows), parent_in_begin_stack)
}

debug_node_viewport :: DebugNodeViewport

debug_render_keyboard_preview :: DebugRenderKeyboardPreview

debug_render_viewport_thumbnail :: DebugRenderViewportThumbnail

is_key_pressed_map :: IsKeyPressedMap

im_font_atlas_get_builder_for_stb_truetype :: ImFontAtlasGetBuilderForStbTruetype

im_font_atlas_build_init :: ImFontAtlasBuildInit

im_font_atlas_build_setup_font :: ImFontAtlasBuildSetupFont

im_font_atlas_build_pack_custom_rects :: ImFontAtlasBuildPackCustomRects

im_font_atlas_build_finish :: ImFontAtlasBuildFinish

im_font_atlas_build_render8bpp_rect_from_string :: proc(atlas: ^Font_Atlas, x: i32, y: i32, w: i32, h: i32, in_str: string, in_marker_char: i8, in_marker_pixel_value: u8) {
	ImFontAtlasBuildRender8bppRectFromString(atlas, x, y, w, h, semisafe_string_to_cstring(in_str), in_marker_char, in_marker_pixel_value)
}

im_font_atlas_build_render32bpp_rect_from_string :: proc(atlas: ^Font_Atlas, x: i32, y: i32, w: i32, h: i32, in_str: string, in_marker_char: i8, in_marker_pixel_value: u32) {
	ImFontAtlasBuildRender32bppRectFromString(atlas, x, y, w, h, semisafe_string_to_cstring(in_str), in_marker_char, in_marker_pixel_value)
}

im_font_atlas_build_multiply_calc_lookup_table :: ImFontAtlasBuildMultiplyCalcLookupTable

im_font_atlas_build_multiply_rect_alpha8 :: ImFontAtlasBuildMultiplyRectAlpha8

log_text :: proc(fmt_: string, _args_: ..any) {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	LogText("%s", cstring(raw_data(_fmt_sb.buf)))
}

text_buffer_appendf :: proc(buffer: ^Text_Buffer, fmt_: string, _args_: ..any) {
	_fmt_sb := strings.builder_make(context.temp_allocator)
	fmt.sbprintf(&_fmt_sb, fmt_, .._args_)
	append(&_fmt_sb.buf, 0)
	TextBuffer_appendf(buffer, "%s", cstring(raw_data(_fmt_sb.buf)))
}

